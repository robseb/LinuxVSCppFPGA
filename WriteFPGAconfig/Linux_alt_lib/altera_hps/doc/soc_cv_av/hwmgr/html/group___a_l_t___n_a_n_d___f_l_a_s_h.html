<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Altera HWLIB: NAND Flash Controller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="altera-logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Altera HWLIB
   &#160;<span id="projectnumber">18.1</span>
   </div>
   <div id="projectbrief">The Altera HW Manager API Reference Manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Address&#160;Space</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_l_t___n_a_n_d___f_l_a_s_h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">ENUMS</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NAND Flash Controller</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This module defines an API for configuration and management of access to NAND flash memory devices through the HPS NAND flash controller.</p>
<p>This API supports the following features:</p>
<ul>
<li>Support for ONFI 1.0 devices or legacy devices that can be identified by the NAND flash controller.</li>
<li>Automatic initialization and discovery of supported NAND flash devices.</li>
<li>ECC protection in hardware.</li>
<li>Erase by block.</li>
<li>Read/Write by (whole) pages.</li>
<li>DMA read/write transfers.</li>
</ul>
<p>This API provides basic I/O operations to unmanaged NAND flash memory with optional hardware assisted ECC protection. This module does not provide higher level flash I/O features such as a flash file system or capabilities for bad block life cycle management or wear leveling.</p>
<p>Support of certain operational features may be device dependent and therefore it is important to consult the data sheet for the specific NAND flash device that the NAND flash controller will interface to.</p>
<p>The comments in this module use the following NAND flash terminology:</p>
<ul>
<li><b>Plane</b> - A collection of blocks typically on a single die of a multi-die device.</li>
<li><b>Block</b> - The basic unit of NAND flash memory. Blocks are the smallest unit that can be erased. Blocks contain pages.</li>
<li><b>Page</b> - A subdivision of a block. It contains the data payload and spare data areas used to store ECC and bad block information.</li>
<li><b>Sector</b> - A subdivision of a page. It contains the data payload protected by ECC.</li>
<li><b>Spare</b> - The area of a page used to store ECC and bad block information.</li>
</ul>
<p>The NAND flash controller uses indexed addressing to operate on flash device blocks or pages. The NAND flash 32-bit address is organized as follows:</p>
<table class="doxtable">
<tr>
<th align="left">Bits </th><th align="left">Description</th></tr>
<tr>
<td align="left">[31:24] </td><td align="left"><em>Reserved - Unused</em> </td></tr>
<tr>
<td align="left">[23:<em>m</em>] </td><td align="left">Specifies the block address portion of the address. </td></tr>
<tr>
<td align="left">[<em>m:0</em>] </td><td align="left">Specifies the page address portion of the address. </td></tr>
</table>
<p>where <em>m</em> depends on the number of pages per block for the flash device.</p>
<p>For functions expecting <em>block_addr</em> parameters, only the bits 23 : <em>m</em> are relevant in a 32-bit address argument value. All other bits should be zero or a ALT_E_BAD_ARG is returned.</p>
<p>For functions expecting <em>page_addr</em> parameters, both the bits <em>m</em> : 0 specifying the page as well as the bits 23 : <em>m</em> specifying the block containing the page are relevant in a 32-bit address argument. All other bits should be zero or a ALT_E_BAD_ARG is returned. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s">ALT_NAND_FLASH_ECC_STATUS_s</a></td></tr>
<tr class="separator:struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2c62a7e4d037b929f9c4ddd88eb7a120"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga2c62a7e4d037b929f9c4ddd88eb7a120">ALT_NAND_INVALID_FLASH_ADDR</a>&#160;&#160;&#160;0xffffffff</td></tr>
<tr class="separator:ga2c62a7e4d037b929f9c4ddd88eb7a120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b2c72277137cd135e6f388d74cd1cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga96b2c72277137cd135e6f388d74cd1cf">ALT_NAND_BAD_BLOCK_MARKER</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga96b2c72277137cd135e6f388d74cd1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf88daac729d36251901500f927397120"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a> )(ALT_STATUS_CODE status, void *callback_arg)</td></tr>
<tr class="separator:gaf88daac729d36251901500f927397120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6594ff22a9a2d753314e3d2d063f2575"><td class="memItemLeft" align="right" valign="top">typedef ALT_STATUS_CODE(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga6594ff22a9a2d753314e3d2d063f2575">alt_nand_flash_custom_init_t</a> )(void *user_arg)</td></tr>
<tr class="separator:ga6594ff22a9a2d753314e3d2d063f2575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93217a678f030b3e6a0dd1809f6c185"><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga1682550cbbde7eb30c0f7d267bb1cb48">ALT_NAND_ECC_CORRECTION_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf93217a678f030b3e6a0dd1809f6c185">ALT_NAND_ECC_CORRECTION_t</a></td></tr>
<tr class="separator:gaf93217a678f030b3e6a0dd1809f6c185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga761bcf5197794df28ecd5b9475efbbbb"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s">ALT_NAND_FLASH_ECC_STATUS_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga761bcf5197794df28ecd5b9475efbbbb">ALT_NAND_FLASH_ECC_STATUS_t</a></td></tr>
<tr class="separator:ga761bcf5197794df28ecd5b9475efbbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdb08b03223d89cff1369c7de005452c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf49f61c3d34a9cf02eb4342760fe8738">ALT_NAND_INT_STATUS_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafdb08b03223d89cff1369c7de005452c">ALT_NAND_INT_STATUS_t</a></td></tr>
<tr class="separator:gafdb08b03223d89cff1369c7de005452c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga460791829165d67f155f73e4674b6f6c"><td class="memItemLeft" align="right" valign="top">typedef uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga460791829165d67f155f73e4674b6f6c">alt_nand_bad_block_table_t</a></td></tr>
<tr class="separator:ga460791829165d67f155f73e4674b6f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
ENUMS</h2></td></tr>
<tr class="memitem:ga1682550cbbde7eb30c0f7d267bb1cb48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga1682550cbbde7eb30c0f7d267bb1cb48">ALT_NAND_ECC_CORRECTION_e</a> </td></tr>
<tr class="separator:ga1682550cbbde7eb30c0f7d267bb1cb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf49f61c3d34a9cf02eb4342760fe8738"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf49f61c3d34a9cf02eb4342760fe8738">ALT_NAND_INT_STATUS_e</a> { <br/>
&#160;&#160;<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a19c1538c330e90b2b706f51b3ce62b9e">ALT_NAND_INT_STATUS_PAGE_XFER_INC</a> = (1 &lt;&lt; 15), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a12ea3e0227434e875d53f680e33897c0">ALT_NAND_INT_STATUS_PIPE_CMD_ERR</a> = (1 &lt;&lt; 14), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738aeca8434d4ed68dc0e95ea07fff14ad6d">ALT_NAND_INT_STATUS_RST_COMP</a> = (1 &lt;&lt; 13), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a8741a914bbf16f28836416118774be6f">ALT_NAND_INT_STATUS_INT_ACT</a> = (1 &lt;&lt; 12), 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a3e22290f75a366e5770ca45f9f6c5981">ALT_NAND_INT_STATUS_UNSUP_CMD</a> = (1 &lt;&lt; 11), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a2046f5d2a1afd3c9e18792df39cfe55e">ALT_NAND_INT_STATUS_LOCKED_BLK</a> = (1 &lt;&lt; 10), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738ae210697ee140594eec8bd2c292bd795c">ALT_NAND_INT_STATUS_PIPE_CPYBCK_CMD_COMP</a> = (1 &lt;&lt; 9), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a035ecc3ee6a8c844f21eb38f8541330f">ALT_NAND_INT_STATUS_ERASE_COMP</a> = (1 &lt;&lt; 8), 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a7748bd4538f2ae67d03263e34caeccbf">ALT_NAND_INT_STATUS_PROGRAM_COMP</a> = (1 &lt;&lt; 7), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738ada62f63b6f19200593cb896a6fbc5fe5">ALT_NAND_INT_STATUS_LOAD_COMP</a> = (1 &lt;&lt; 6), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a94c6f95209eb7e5dab714cba954f7c09">ALT_NAND_INT_STATUS_ERASE_FAIL</a> = (1 &lt;&lt; 5), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a2cf2e5f32ff4e2abdb9fe036ce627640">ALT_NAND_INT_STATUS_PROGRAM_FAIL</a> = (1 &lt;&lt; 4), 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a8167c72416c2dc6112a9f38bddb7d40a">ALT_NAND_INT_STATUS_TIME_OUT</a> = (1 &lt;&lt; 3), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a2610a25ae207f0c530f7117c85233aa2">ALT_NAND_INT_STATUS_DMA_CMD_COMP</a> = (1 &lt;&lt; 2), 
<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ggaf49f61c3d34a9cf02eb4342760fe8738a16009d31725ede296363e21f69777315">ALT_NAND_INT_STATUS_ECC_UNCOR_ERR</a> = (1 &lt;&lt; 0)
<br/>
 }</td></tr>
<tr class="separator:gaf49f61c3d34a9cf02eb4342760fe8738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9240a17e7222f4ac3e32362cdcae523d"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga9240a17e7222f4ac3e32362cdcae523d">alt_nand_init</a> (const bool load_block0_page0, const bool page_size_512, <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga6594ff22a9a2d753314e3d2d063f2575">alt_nand_flash_custom_init_t</a> custom_init, void *user_arg)</td></tr>
<tr class="separator:ga9240a17e7222f4ac3e32362cdcae523d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad3fdd9664a4adfeef7810a8fee483f"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga1ad3fdd9664a4adfeef7810a8fee483f">alt_nand_uninit</a> (void)</td></tr>
<tr class="separator:ga1ad3fdd9664a4adfeef7810a8fee483f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade68e1d52f73ed2447638313ccbe4f06"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gade68e1d52f73ed2447638313ccbe4f06">alt_nand_block_address_get</a> (const uint32_t addr)</td></tr>
<tr class="separator:gade68e1d52f73ed2447638313ccbe4f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ce193d11bb66b2776f61b5f072bdb21"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga3ce193d11bb66b2776f61b5f072bdb21">alt_nand_page_address_get</a> (const uint32_t addr)</td></tr>
<tr class="separator:ga3ce193d11bb66b2776f61b5f072bdb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f6044b18867ba3b65b89330d7647e86"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga7f6044b18867ba3b65b89330d7647e86">alt_nand_addr_compose</a> (const uint32_t block_num, const uint32_t page_num)</td></tr>
<tr class="separator:ga7f6044b18867ba3b65b89330d7647e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadece9e0e96052c5ae3453130a86c7dc4"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gadece9e0e96052c5ae3453130a86c7dc4">alt_nand_block_erase</a> (const uint32_t block_addr, <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a> completion_callback, void *completion_arg)</td></tr>
<tr class="separator:gadece9e0e96052c5ae3453130a86c7dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63e8dc4472c48c309b403b044892f615"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga63e8dc4472c48c309b403b044892f615">alt_nand_page_read</a> (const uint32_t page_addr, const uint32_t num_pages, void *dest, const uint32_t dest_size)</td></tr>
<tr class="separator:ga63e8dc4472c48c309b403b044892f615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ae6124e08a5c41afb7a2af153e25f2"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga09ae6124e08a5c41afb7a2af153e25f2">alt_nand_read_page</a> (uint32_t block, uint32_t page, uint32_t *buf)</td></tr>
<tr class="separator:ga09ae6124e08a5c41afb7a2af153e25f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81cf7328396bda05c918a6be27190ef"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gad81cf7328396bda05c918a6be27190ef">alt_nand_read_page_and_spare</a> (uint32_t block, uint32_t page, uint32_t *buf)</td></tr>
<tr class="separator:gad81cf7328396bda05c918a6be27190ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422bb642531867cc7e9004efe13b272c"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga422bb642531867cc7e9004efe13b272c">alt_nand_read_page_and_spare_byte</a> (uint32_t block, uint32_t page, uint8_t *buf)</td></tr>
<tr class="separator:ga422bb642531867cc7e9004efe13b272c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cb46fe3144c962f0c0b7fbb2314841e"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga6cb46fe3144c962f0c0b7fbb2314841e">alt_nand_page_write</a> (const uint32_t page_addr, const uint32_t num_pages, const void *src, const uint32_t src_size)</td></tr>
<tr class="separator:ga6cb46fe3144c962f0c0b7fbb2314841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef72155c1ec35315920c99d2bacb0252"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaef72155c1ec35315920c99d2bacb0252">alt_nand_write_page</a> (uint32_t block, uint32_t page, uint32_t *buf)</td></tr>
<tr class="separator:gaef72155c1ec35315920c99d2bacb0252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb6bb22fb5831da60bfda3d132a959dd"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaeb6bb22fb5831da60bfda3d132a959dd">alt_nand_write_page_and_spare</a> (uint32_t block, uint32_t page, uint32_t *buf)</td></tr>
<tr class="separator:gaeb6bb22fb5831da60bfda3d132a959dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43720b5ae6d4afd3d5a4c0e91c7b32f4"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga43720b5ae6d4afd3d5a4c0e91c7b32f4">alt_nand_page_dma_read</a> (const uint32_t page_addr, const uint32_t num_pages, void *dest, const uint32_t dest_size, <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a> completion_callback, void *completion_arg)</td></tr>
<tr class="separator:ga43720b5ae6d4afd3d5a4c0e91c7b32f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35a8af32fd0ffefd02f9929d3d1455b"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gad35a8af32fd0ffefd02f9929d3d1455b">alt_nand_page_dma_write</a> (const uint32_t page_addr, const uint32_t num_pages, const void *src, const uint32_t src_size, <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a> completion_callback, void *completion_arg)</td></tr>
<tr class="separator:gad35a8af32fd0ffefd02f9929d3d1455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebea935dff5aca87369a21f61c088f59"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaebea935dff5aca87369a21f61c088f59">alt_nand_ecc_enable</a> (const <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf93217a678f030b3e6a0dd1809f6c185">ALT_NAND_ECC_CORRECTION_t</a> ecc_correction)</td></tr>
<tr class="separator:gaebea935dff5aca87369a21f61c088f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d996102c6f4151d4b4e0f680dc2b32d"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga9d996102c6f4151d4b4e0f680dc2b32d">alt_nand_ecc_disable</a> (void)</td></tr>
<tr class="separator:ga9d996102c6f4151d4b4e0f680dc2b32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f810dd954cac99fd0f8afec3cd2fe1e"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga9f810dd954cac99fd0f8afec3cd2fe1e">alt_nand_ecc_status_get</a> (<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga761bcf5197794df28ecd5b9475efbbbb">ALT_NAND_FLASH_ECC_STATUS_t</a> *ecc_status)</td></tr>
<tr class="separator:ga9f810dd954cac99fd0f8afec3cd2fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad07055d6b7085c35b8595ac69399ac8d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gad07055d6b7085c35b8595ac69399ac8d">alt_nand_int_status_get</a> (void)</td></tr>
<tr class="separator:gad07055d6b7085c35b8595ac69399ac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac209163ddc12274eda840908b5605b04"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gac209163ddc12274eda840908b5605b04">alt_nand_int_clear</a> (const uint32_t mask)</td></tr>
<tr class="separator:gac209163ddc12274eda840908b5605b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga341fa15b005227867ca03f08287446e7"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga341fa15b005227867ca03f08287446e7">alt_nand_int_disable</a> (const uint32_t mask)</td></tr>
<tr class="separator:ga341fa15b005227867ca03f08287446e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c3c895449b51f7f4c7644df6668193e"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga2c3c895449b51f7f4c7644df6668193e">alt_nand_int_enable</a> (const uint32_t mask)</td></tr>
<tr class="separator:ga2c3c895449b51f7f4c7644df6668193e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7114047503fabc69006abb0d0292147"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gab7114047503fabc69006abb0d0292147">alt_nand_num_planes_get</a> (void)</td></tr>
<tr class="separator:gab7114047503fabc69006abb0d0292147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917cc11557a5326ead707c9bf4268ce5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga917cc11557a5326ead707c9bf4268ce5">alt_nand_num_blocks_get</a> (void)</td></tr>
<tr class="separator:ga917cc11557a5326ead707c9bf4268ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb27292643155c86fcbb94437b52d3a4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafb27292643155c86fcbb94437b52d3a4">alt_nand_num_pages_per_block_get</a> (void)</td></tr>
<tr class="separator:gafb27292643155c86fcbb94437b52d3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5fe60215487fafeaa38495f30755430"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaa5fe60215487fafeaa38495f30755430">alt_nand_page_size_get</a> (void)</td></tr>
<tr class="separator:gaa5fe60215487fafeaa38495f30755430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga487de3722a0d34dcc937d6c513990ccc"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga487de3722a0d34dcc937d6c513990ccc">alt_nand_page_size_32_get</a> (void)</td></tr>
<tr class="separator:ga487de3722a0d34dcc937d6c513990ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4de109ff1cfa88d2e337088dbca3435"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gad4de109ff1cfa88d2e337088dbca3435">alt_nand_spare_size_get</a> (void)</td></tr>
<tr class="separator:gad4de109ff1cfa88d2e337088dbca3435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae274321c5779321bfa29c7a3446c73fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gae274321c5779321bfa29c7a3446c73fa">alt_nand_block_is_bad</a> (const uint32_t block_addr)</td></tr>
<tr class="separator:gae274321c5779321bfa29c7a3446c73fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd42b58de806ab8e3da97df0a1b55a50"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gadd42b58de806ab8e3da97df0a1b55a50">alt_nand_bad_block_table_get</a> (<a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga460791829165d67f155f73e4674b6f6c">alt_nand_bad_block_table_t</a> bad_block_table, const uint32_t bad_block_table_len)</td></tr>
<tr class="separator:gadd42b58de806ab8e3da97df0a1b55a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s" id="struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ALT_NAND_FLASH_ECC_STATUS_s</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This type defines a structure for accessing the ECC error correction information for the last transaction completed by the NAND flash controller. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae655451521804bfe8e2e102a36bb10cb"></a>uint32_t</td>
<td class="fieldname">
corrected_errors</td>
<td class="fielddoc">
Maximum of number of errors corrected per sector in a bank. This field is not valid for uncorrectable errors. A value of zero indicates that no ECC error occurred in last completed transaction. Index <em>n</em> corressponds to bank <em>n</em>. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a139307a42dba1dca93a2f5e5768ce168"></a>bool</td>
<td class="fieldname">
uncorrected_error</td>
<td class="fielddoc">
<b>true</b> if an uncorrectable error occurred while reading pages for last transaction in a bank. Uncorrectable errors also generate ALT_NAND_INT_STATUS_ECC_UNCOR_ERR interrupt status conditions. Index <em>n</em> corressponds to bank <em>n</em>. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definitions</h2>
<a class="anchor" id="ga2c62a7e4d037b929f9c4ddd88eb7a120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALT_NAND_INVALID_FLASH_ADDR&#160;&#160;&#160;0xffffffff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines an value to represent an invalid or bad flash device address. </p>

</div>
</div>
<a class="anchor" id="ga96b2c72277137cd135e6f388d74cd1cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALT_NAND_BAD_BLOCK_MARKER&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The ONFI Factory Defect Mapping defined value used by manufacturers to mark a block as defective. A manufacturer marks defective blocks by setting at least one byte in the spare area of the first or last page of the defective block to a value of 0. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gaf88daac729d36251901500f927397120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* alt_nand_callback_t)(ALT_STATUS_CODE status, void *callback_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type definition for a callback function prototype used by NAND flash controller API functions to notify users of asynchronous operation completion or operational error status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The final status of the asynchronous operation success or failure.</td></tr>
    <tr><td class="paramname">completion_arg</td><td>A pointer for passing user defined data. The content of this parameter is user defined and is passed when the asynchronous operation is initiated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6594ff22a9a2d753314e3d2d063f2575"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ALT_STATUS_CODE(* alt_nand_flash_custom_init_t)(void *user_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type definition for a user defined custom flash device initialization function. This function should be provided for flash devices that do not support automatic device discovery and parameter configuration or devices where customized settings are desired.</p>
<p>This function is invoked by the alt_nand_flash_init() routine at the proper point during the NAND flash controller initialization process.</p>
<p>Returning any status code other than ALT_E_SUCCESS from this custom initialization function will cause the alt_nand_flash_init() function to fail as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">user_arg</td><td>A pointer for optionally passing user defined data. The content of this parameter is user defined and its value may be NULL if unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Custom flash device initialization was successful. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Custom flash device initialization failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf93217a678f030b3e6a0dd1809f6c185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga1682550cbbde7eb30c0f7d267bb1cb48">ALT_NAND_ECC_CORRECTION_e</a>  <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf93217a678f030b3e6a0dd1809f6c185">ALT_NAND_ECC_CORRECTION_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type definition enumerates the possible ECC correction code bit encodings and their applicability to sector size. </p>

</div>
</div>
<a class="anchor" id="ga761bcf5197794df28ecd5b9475efbbbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#struct_a_l_t___n_a_n_d___f_l_a_s_h___e_c_c___s_t_a_t_u_s__s">ALT_NAND_FLASH_ECC_STATUS_s</a>  <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga761bcf5197794df28ecd5b9475efbbbb">ALT_NAND_FLASH_ECC_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type defines a structure for accessing the ECC error correction information for the last transaction completed by the NAND flash controller. </p>

</div>
</div>
<a class="anchor" id="gafdb08b03223d89cff1369c7de005452c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf49f61c3d34a9cf02eb4342760fe8738">ALT_NAND_INT_STATUS_e</a>  <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafdb08b03223d89cff1369c7de005452c">ALT_NAND_INT_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type definition enumerates the interrupt status conditions for the NAND flash controller.</p>
<p>The enumerations serve as masks for the NAND flash controller events that can be set when the designated conditions occur and the corresponding event is enabled. When any of these event source conditions are true, the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt output is asserted high.</p>
<p>Interrupt sources are cleared when software calls <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gac209163ddc12274eda840908b5605b04">alt_nand_int_clear()</a>. The interrupt sources are individually maskable using <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga341fa15b005227867ca03f08287446e7">alt_nand_int_disable()</a> and <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga2c3c895449b51f7f4c7644df6668193e">alt_nand_int_enable()</a>.</p>
<p>The NAND flash controller has a single active high interrupt output (nand_int). This interrupt is the logical "OR" of all of the interrupt bits within the flash controller that are enabled and set. There is also a global interrupt enable in the flash controller block that must be set to enable interrupts. Each interrupt source within the IP has an active high enable bit and a sticky bit. The sticky bit is an active high "write one to clear" status bit. There are four sets of identical interrupt bits, one for each of the four banks. The following conditions can trigger an interrupt:</p>
<ul>
<li>Page transfer</li>
<li>Pipeline command sequence violation</li>
<li>Rest/initialization complete</li>
<li>Ready/Busy pin low to high transition</li>
<li>Unsupported command</li>
<li>Locked block command failure</li>
<li>Pipeline command or copyback command complete</li>
<li>Erase complete</li>
<li>Program complete</li>
<li>Load complete</li>
<li>Erase fail</li>
<li>Program fail</li>
<li>Timeout</li>
<li>DMA command complete</li>
<li>Uncorrectable ECC error </li>
</ul>

</div>
</div>
<a class="anchor" id="ga460791829165d67f155f73e4674b6f6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t* <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga460791829165d67f155f73e4674b6f6c">alt_nand_bad_block_table_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type defines the data structure used to hold the bad block table.</p>
<p>The table is an array composed of uint32_t elements. Each array element contains the bad block status for 32 consecutive blocks on the flash device. The array is of length <em>ceil( <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga917cc11557a5326ead707c9bf4268ce5">alt_nand_num_blocks_get()</a> / 32 )</em> elements.</p>
<p>Each bit holds the defect status of a block in the device. The LSB bit position of the first element of the array corressponds to the defect status of Block 0. The MSB of the first element of the array corressponds to the defect status of Block 31. The second element of the array contains the defect status of the next 32 consecutive blocks of the device (Blocks 32-63) and so on.</p>
<p>The following code fragment illustrates how the bad block table is used to determine whether a particular block is bad or not:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ALT_NAND_GOOD_BLOCK_FLAG     0</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define ALT_NAND_BAD_BLOCK_FLAG      1</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">block_is_bad = <span class="keyword">false</span>;</div>
<div class="line">block_table_index = block_number / 32;</div>
<div class="line">block_bit_position = block_number % 32;</div>
<div class="line"><span class="keywordflow">if</span> ((( bad_block_table[block_table_index] &gt;&gt; block_bit_position) &amp; 0x1) == ALT_NAND_BAD_BLOCK_FLAG)</div>
<div class="line">    block_is_bad = <span class="keyword">true</span>;</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1682550cbbde7eb30c0f7d267bb1cb48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga1682550cbbde7eb30c0f7d267bb1cb48">ALT_NAND_ECC_CORRECTION_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type definition enumerates the possible ECC correction code bit encodings and their applicability to sector size. </p>

</div>
</div>
<a class="anchor" id="gaf49f61c3d34a9cf02eb4342760fe8738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf49f61c3d34a9cf02eb4342760fe8738">ALT_NAND_INT_STATUS_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type definition enumerates the interrupt status conditions for the NAND flash controller.</p>
<p>The enumerations serve as masks for the NAND flash controller events that can be set when the designated conditions occur and the corresponding event is enabled. When any of these event source conditions are true, the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt output is asserted high.</p>
<p>Interrupt sources are cleared when software calls <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gac209163ddc12274eda840908b5605b04">alt_nand_int_clear()</a>. The interrupt sources are individually maskable using <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga341fa15b005227867ca03f08287446e7">alt_nand_int_disable()</a> and <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga2c3c895449b51f7f4c7644df6668193e">alt_nand_int_enable()</a>.</p>
<p>The NAND flash controller has a single active high interrupt output (nand_int). This interrupt is the logical "OR" of all of the interrupt bits within the flash controller that are enabled and set. There is also a global interrupt enable in the flash controller block that must be set to enable interrupts. Each interrupt source within the IP has an active high enable bit and a sticky bit. The sticky bit is an active high "write one to clear" status bit. There are four sets of identical interrupt bits, one for each of the four banks. The following conditions can trigger an interrupt:</p>
<ul>
<li>Page transfer</li>
<li>Pipeline command sequence violation</li>
<li>Rest/initialization complete</li>
<li>Ready/Busy pin low to high transition</li>
<li>Unsupported command</li>
<li>Locked block command failure</li>
<li>Pipeline command or copyback command complete</li>
<li>Erase complete</li>
<li>Program complete</li>
<li>Load complete</li>
<li>Erase fail</li>
<li>Program fail</li>
<li>Timeout</li>
<li>DMA command complete</li>
<li>Uncorrectable ECC error </li>
</ul>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a19c1538c330e90b2b706f51b3ce62b9e"></a>ALT_NAND_INT_STATUS_PAGE_XFER_INC</em>&nbsp;</td><td>
<p>For every page of data transfer to or from the device, this status will be set. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a12ea3e0227434e875d53f680e33897c0"></a>ALT_NAND_INT_STATUS_PIPE_CMD_ERR</em>&nbsp;</td><td>
<p>A pipeline command sequence has been violated. This occurs when MAP01 page read/write address does not match the corresponding expected address from the pipeline commands issued earlier. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738aeca8434d4ed68dc0e95ea07fff14ad6d"></a>ALT_NAND_INT_STATUS_RST_COMP</em>&nbsp;</td><td>
<p>The NAND flash controller has finished reset and initialization process. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a8741a914bbf16f28836416118774be6f"></a>ALT_NAND_INT_STATUS_INT_ACT</em>&nbsp;</td><td>
<p>R/B pin of device transitioned from low to high. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a3e22290f75a366e5770ca45f9f6c5981"></a>ALT_NAND_INT_STATUS_UNSUP_CMD</em>&nbsp;</td><td>
<p>An unsupported command was received. This interrupt is set when an invalid command is received, or when a command sequence is broken. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a2046f5d2a1afd3c9e18792df39cfe55e"></a>ALT_NAND_INT_STATUS_LOCKED_BLK</em>&nbsp;</td><td>
<p>The address to program or erase operation is to a locked block and the operation failed due to this reason. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738ae210697ee140594eec8bd2c292bd795c"></a>ALT_NAND_INT_STATUS_PIPE_CPYBCK_CMD_COMP</em>&nbsp;</td><td>
<p>A pipeline command or a copyback bank command has completed on this particular bank. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a035ecc3ee6a8c844f21eb38f8541330f"></a>ALT_NAND_INT_STATUS_ERASE_COMP</em>&nbsp;</td><td>
<p>Device erase operation complete. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a7748bd4538f2ae67d03263e34caeccbf"></a>ALT_NAND_INT_STATUS_PROGRAM_COMP</em>&nbsp;</td><td>
<p>Device finished the last issued program command. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738ada62f63b6f19200593cb896a6fbc5fe5"></a>ALT_NAND_INT_STATUS_LOAD_COMP</em>&nbsp;</td><td>
<p>Device finished the last issued load command. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a94c6f95209eb7e5dab714cba954f7c09"></a>ALT_NAND_INT_STATUS_ERASE_FAIL</em>&nbsp;</td><td>
<p>Erase failure occurred in the device on issuance of a erase command. err_block_addr and err_page_addr contain the block address and page address that failed erase operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a2cf2e5f32ff4e2abdb9fe036ce627640"></a>ALT_NAND_INT_STATUS_PROGRAM_FAIL</em>&nbsp;</td><td>
<p>Program failure occurred in the device on issuance of a program command. err_block_addr and err_page_addr contain the block address and page address that failed program operation. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a8167c72416c2dc6112a9f38bddb7d40a"></a>ALT_NAND_INT_STATUS_TIME_OUT</em>&nbsp;</td><td>
<p>Watchdog timer has triggered in the controller due to one of the reasons like device not responding or controller state machine did not get back to idle. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a2610a25ae207f0c530f7117c85233aa2"></a>ALT_NAND_INT_STATUS_DMA_CMD_COMP</em>&nbsp;</td><td>
<p>A data DMA command has completed on this bank. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggaf49f61c3d34a9cf02eb4342760fe8738a16009d31725ede296363e21f69777315"></a>ALT_NAND_INT_STATUS_ECC_UNCOR_ERR</em>&nbsp;</td><td>
<p>ECC logic detected uncorrectable error while reading data from flash device. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9240a17e7222f4ac3e32362cdcae523d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_init </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>load_block0_page0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>page_size_512</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga6594ff22a9a2d753314e3d2d063f2575">alt_nand_flash_custom_init_t</a>&#160;</td>
          <td class="paramname"><em>custom_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function initializes the NAND flash controller and attached flash device by:</p>
<ul>
<li>Taking the NAND flash controller out of reset.</li>
<li>Performing automatic NAND flash device discovery and parameter configuration for supported devices.</li>
<li>Optionally loading block 0, page 0 of the device and configuring direct read access (preloader use case only).</li>
<li>And assuming the device discovery and parameter configuration (automatic or custom) process is successful, then scans the device for blocks marked as defective at manufacture time and builds a bad block table. The bad block table is used at runtime to avoid erasing or programming any block marked as defective.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">load_block0_page0</td><td>If <b>true</b> then load block 0, page 0 from the flash device and configure the NAND flash controller for direct read access. This option is typically used by custom preloaders and should be set to <b>false</b> by most users.</td></tr>
    <tr><td class="paramname">page_size_512</td><td>If <b>true</b> the flash device has a 512 byte page size. This type of device typically does not support automatic discovery and therefore requires custom flash device initialization via the <em>custom_init</em> function.</td></tr>
    <tr><td class="paramname">custom_init</td><td>A pointer to a user defined function to perform customized flash device initialization. The function must program the applicable NAND flash controller registers in the config group based on specific device features and operational performance parameters. The NAND flash controller registers are accessible via the NAND flash controller SoCAL header file "socal/alt_nand.h". A NULL value for this parameter allows the NAND flash controller to do automatic device discovery and parameter configuration. A NULL value should normally be passed for ONFI and supported legacy flash devices.</td></tr>
    <tr><td class="paramname">user_arg</td><td>A user defined argument that is passed to the custom initialization function when invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1ad3fdd9664a4adfeef7810a8fee483f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_uninit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uninitialize the NAND flash controller.</p>
<p>Uninitialize the NAND flash controller by putting the flash controller into reset.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade68e1d52f73ed2447638313ccbe4f06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_block_address_get </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the block number of the specified block or page address. The returned block address is right shift aligned to bit 0.</p>
<p>This function may be used after a successful call to alt_nand_flash_init().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A block or page address value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit 0 right aligned block address portion of the <em>addr</em> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ce193d11bb66b2776f61b5f072bdb21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_page_address_get </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the page number of the specified block or page address. The returned page address is right shift aligned to bit 0.</p>
<p>This function may be used after a successful call to alt_nand_flash_init().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>A block or page address value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit 0 right aligned page address portion of the <em>addr</em> argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f6044b18867ba3b65b89330d7647e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_addr_compose </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>block_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a valid block or page address for a flash device with the given block and page argument values.</p>
<p>This function may be used after a successful call to alt_nand_flash_init().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_num</td><td>The flash device block number to use in composing the final flash device address.</td></tr>
    <tr><td class="paramname">page_num</td><td>The flash device page number within the block to use in composing the final flash device address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid block or page address for the flash device. ALT_NAND_INVALID_FLASH_ADDR is returned if either of the <em>block_num</em> or <em>page_num</em> arguments is invalid for the device. </dd></dl>

</div>
</div>
<a class="anchor" id="gadece9e0e96052c5ae3453130a86c7dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_block_erase </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>block_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a>&#160;</td>
          <td class="paramname"><em>completion_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>completion_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Erases the designated flash device block.</p>
<p>Erases the flash device block designated by <em>block_addr</em>. The erase operation proceeds asynchronously with a user callback notification upon completion or error.</p>
<p>Flash memory must be erased before being written. Erasing sets all bits in a given block of flash memory to '1' which is the erased state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_addr</td><td>The block address to erase.</td></tr>
    <tr><td class="paramname">completion_callback</td><td>A user defined callback function that is called when the operation completes or an error occurs.</td></tr>
    <tr><td class="paramname">completion_arg</td><td>A user defined argument that is passed to the callback function when the operation completes or an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
    <tr><td class="paramname">ALT_E_BAD_BLK</td><td>One or more device block(s) are marked defective and hence the operation was ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63e8dc4472c48c309b403b044892f615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_page_read </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one or more pages from the flash device.</p>
<p>Reads <em>num_pages</em> from the flash device beginning at <em>page_addr</em>. Whole pages are read from flash memory. The pages are copied into the <em>dest</em> location.</p>
<p>If ECC is enabled then the NAND flash controller performs ECC correction and detection on the fly as data is read from the device and before being transferred out of the controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>The beginning page address to read.</td></tr>
    <tr><td class="paramname">num_pages</td><td>The number of pages to read.</td></tr>
    <tr><td class="paramname">dest</td><td>The address of the destination buffer.</td></tr>
    <tr><td class="paramname">dest_size</td><td>The size of the destination buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
    <tr><td class="paramname">ALT_E_BAD_BLK</td><td>The device block is marked defective and hence the operation was ignored. </td></tr>
    <tr><td class="paramname">ALT_E_BUF_OVF</td><td>The destination buffer does not contain enough space for the operation. </td></tr>
    <tr><td class="paramname">ALT_E_ECC_UNCOR</td><td>An uncorrected ECC error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09ae6124e08a5c41afb7a2af153e25f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_read_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one page from the flash device.</p>
<p>Reads a page from the flash device beginning at <em>page_addr</em>. One whole page is read from flash memory. The page is copied into the <em>buf</em> location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block number of the page to be read.</td></tr>
    <tr><td class="paramname">page</td><td>The page number to be read.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad81cf7328396bda05c918a6be27190ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_read_page_and_spare </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one page and its spare area from the flash device.</p>
<p>Reads a page and its spare area from the flash device beginning at <em>page_addr</em>. One whole page and its spare area is read from flash memory. The page and the spare area is copied into the <em>buf</em> location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block number of the page to be read.</td></tr>
    <tr><td class="paramname">page</td><td>The page number to be read.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga422bb642531867cc7e9004efe13b272c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_read_page_and_spare_byte </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one page and its spare area from the flash device one byte at a time.</p>
<p>Reads a page and its spare area from the flash device beginning at <em>page_addr</em>. One whole page and its spare area is read from flash memory. The page and the spare area is copied into the <em>buf</em> location. This function reads the page one byte at a time into an 8-bit buffer rather than using 32-bit buffers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block number of the page to be read.</td></tr>
    <tr><td class="paramname">page</td><td>The page number to be read.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6cb46fe3144c962f0c0b7fbb2314841e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_page_write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>src_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write one or more pages to the flash device.</p>
<p>Writes <em>num_pages</em> to the flash device beginning at <em>page_addr</em>. Whole pages are written to flash memory. The block(s) containing the pages must have been previously erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>The beginning page address to write.</td></tr>
    <tr><td class="paramname">num_pages</td><td>The number of pages to write.</td></tr>
    <tr><td class="paramname">src</td><td>The address of the source buffer containing the data to be written to the flash device.</td></tr>
    <tr><td class="paramname">src_size</td><td>The size of the source buffer in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
    <tr><td class="paramname">ALT_E_BAD_BLK</td><td>The device block is marked defective and hence the operation was ignored. </td></tr>
    <tr><td class="paramname">ALT_E_BUF_OVF</td><td>The source buffer is larger than the flash device page(s) destination. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef72155c1ec35315920c99d2bacb0252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_write_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write one page to the flash device.</p>
<p>Writes a page to the flash device. One whole page is written to flash memory. The page is copied from the <em>buf</em> location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block number of the page to write.</td></tr>
    <tr><td class="paramname">page</td><td>The page number to be read.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb6bb22fb5831da60bfda3d132a959dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_write_page_and_spare </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write one page and its spare area to the flash device.</p>
<p>Writes a page and its spare area to the flash device. One whole page and its spare area is written to flash memory. The page is copied from the <em>buf</em> location.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block number of the page to write.</td></tr>
    <tr><td class="paramname">page</td><td>The page number to be read.</td></tr>
    <tr><td class="paramname">buf</td><td>The address of the destination buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga43720b5ae6d4afd3d5a4c0e91c7b32f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_page_dma_read </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a>&#160;</td>
          <td class="paramname"><em>completion_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>completion_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read one or more pages from the flash device using the NAND flash controller's internal DMA. The read operation proceeds asynchronously with a user callback notification upon completion or error.</p>
<p>Reads <em>num_pages</em> from the flash device beginning at <em>page_addr</em>. Whole pages are read from flash memory. The pages are copied into the <em>dest</em> location.</p>
<p>If ECC is enabled then the NAND flash controller performs ECC correction and detection on the fly as data is read from the device and before being transferred out of the controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>The beginning page address to read.</td></tr>
    <tr><td class="paramname">num_pages</td><td>The number of pages to read.</td></tr>
    <tr><td class="paramname">dest</td><td>The address of the destination buffer.</td></tr>
    <tr><td class="paramname">dest_size</td><td>The size of the destination buffer in bytes.</td></tr>
    <tr><td class="paramname">completion_callback</td><td>A user defined callback function that is called when the operation completes or an error occurs.</td></tr>
    <tr><td class="paramname">completion_arg</td><td>A user defined argument that is passed to the callback function when the operation completes or an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
    <tr><td class="paramname">ALT_E_BAD_BLK</td><td>The device block is marked defective and hence the operation was ignored. </td></tr>
    <tr><td class="paramname">ALT_E_BUF_OVF</td><td>The destination buffer does not contain enough space for the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad35a8af32fd0ffefd02f9929d3d1455b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_page_dma_write </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>num_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>src_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf88daac729d36251901500f927397120">alt_nand_callback_t</a>&#160;</td>
          <td class="paramname"><em>completion_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>completion_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write one or more pages to the flash device using the NAND flash controller's internal DMA. The write operation proceeds asynchronously with a user callback notification upon completion or error.</p>
<p>Writes <em>num_pages</em> to the flash device beginning at <em>page_addr</em>. Whole pages are written to flash memory. The block(s) containing the pages must have been previously erased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_addr</td><td>The beginning page address to write.</td></tr>
    <tr><td class="paramname">num_pages</td><td>The number of pages to write.</td></tr>
    <tr><td class="paramname">src</td><td>The address of the source buffer containing th data to be written to the flash device.</td></tr>
    <tr><td class="paramname">src_size</td><td>The size of the source buffer in bytes.</td></tr>
    <tr><td class="paramname">completion_callback</td><td>A user defined callback function that is called when the operation completes or an error occurs.</td></tr>
    <tr><td class="paramname">completion_arg</td><td>A user defined argument that is passed to the callback function when the operation completes or an error occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
    <tr><td class="paramname">ALT_E_BAD_BLK</td><td>The device block is marked defective and hence the operation was ignored. </td></tr>
    <tr><td class="paramname">ALT_E_BUF_OVF</td><td>The destination buffer does not contain enough space for the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaebea935dff5aca87369a21f61c088f59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_ecc_enable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gaf93217a678f030b3e6a0dd1809f6c185">ALT_NAND_ECC_CORRECTION_t</a>&#160;</td>
          <td class="paramname"><em>ecc_correction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable hardware ECC protection for the flash device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ecc_correction</td><td>The desired ECC correction code bit encoding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
    <tr><td class="paramname">ALT_E_INV_OPTION</td><td>The specified ECC correction value is not appropriate for the device page size and spare area available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9d996102c6f4151d4b4e0f680dc2b32d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_ecc_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable hardware ECC protection for the flash device.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f810dd954cac99fd0f8afec3cd2fe1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_ecc_status_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga761bcf5197794df28ecd5b9475efbbbb">ALT_NAND_FLASH_ECC_STATUS_t</a> *&#160;</td>
          <td class="paramname"><em>ecc_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the ECC error correction information for the last transaction completed by the NAND flash controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ecc_status</td><td>[out] Pointer to a <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga761bcf5197794df28ecd5b9475efbbbb">ALT_NAND_FLASH_ECC_STATUS_t</a> structure containing the ECC status for the last completed transaction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad07055d6b7085c35b8595ac69399ac8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_int_status_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the NAND flash controller interrupt status register value.</p>
<p>This function returns the current value of the NAND flash controller interrupt status register value which reflects the current NAND flash controller status conditions.</p>
<dl class="section return"><dt>Returns</dt><dd>The current value of the NAND flash controller interrupt status register value which reflects the current NAND flash controller status conditions as defined by the <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafdb08b03223d89cff1369c7de005452c">ALT_NAND_INT_STATUS_t</a> mask. If the corresponding bit is set then the condition is asserted. </dd></dl>

</div>
</div>
<a class="anchor" id="gac209163ddc12274eda840908b5605b04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_int_clear </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the specified NAND flash controller interrupt status conditions identified in the mask.</p>
<p>This function clears one or more of the status conditions as contributors to the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt signal state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Specifies the QSPI interrupt status conditions to clear. <em>mask</em> is a mask of logically OR'ed <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafdb08b03223d89cff1369c7de005452c">ALT_NAND_INT_STATUS_t</a> values that designate the status conditions to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga341fa15b005227867ca03f08287446e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_int_disable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disable the specified NAND flash controller interrupt status conditions identified in the mask.</p>
<p>This function disables one or more of the status conditions as contributors to the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt signal state.</p>
<p>NOTE: A cleared bit for any status condition in the mask value does not have the effect of enabling it as a contributor to the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt signal state. The function <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga2c3c895449b51f7f4c7644df6668193e">alt_nand_int_enable()</a> is used to enable status source conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Specifies the status conditions to disable as interrupt source contributors. <em>mask</em> is a mask of logically OR'ed <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafdb08b03223d89cff1369c7de005452c">ALT_NAND_INT_STATUS_t</a> values that designate the status conditions to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c3c895449b51f7f4c7644df6668193e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_int_enable </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable the specified NAND flash controller interrupt status conditions identified in the mask.</p>
<p>This function enables one or more of the status conditions as contributors to the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt signal state.</p>
<p>NOTE: A cleared bit for any status condition in the mask value does not have the effect of disabling it as a contributor to the <b>ALT_INT_INTERRUPT_NAND_IRQ</b> interrupt signal state. The function <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga341fa15b005227867ca03f08287446e7">alt_nand_int_disable()</a> is used to disable status source conditions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Specifies the status conditions to enable as interrupt source contributors. <em>mask</em> is a mask of logically OR'ed <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#gafdb08b03223d89cff1369c7de005452c">ALT_NAND_INT_STATUS_t</a> values that designate the status conditions to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab7114047503fabc69006abb0d0292147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_num_planes_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of planes in the flash memory device.</p>
<p>Returns the number of planes as read from the device during discovery and parameter configuration. For 512 byte devices this information typically has to be manually programmed by software.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of planes contained in the device. </dd></dl>

</div>
</div>
<a class="anchor" id="ga917cc11557a5326ead707c9bf4268ce5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_num_blocks_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of blocks in the flash memory device.</p>
<p>Returns the number of blocks as read from the device during discovery and parameter configuration. For 512 byte devices this information typically has to be manually programmed by software.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of blocks contained in the device. </dd></dl>

</div>
</div>
<a class="anchor" id="gafb27292643155c86fcbb94437b52d3a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_num_pages_per_block_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returnes the number of pages per device block.</p>
<p>Returns the number of pages per block as read from the device during discovery and parameter configuration. For 512 byte devices this information typically has to be manually programmed by software.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of pages per device block. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5fe60215487fafeaa38495f30755430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_page_size_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of a page in bytes.</p>
<p>Returns the size of a page in bytes as read from the device during discovery and parameter configuration. For 512 byte devices this information typically has to be manually programmed by software.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of a page in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ga487de3722a0d34dcc937d6c513990ccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_page_size_32_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of a page in 32-bit words.</p>
<p>Returns the size of a page in 32-bit words as read from the device during discovery and parameter configuration. For 512 byte devices this information typically has to be manually programmed by software.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of a page in 32-bit words. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4de109ff1cfa88d2e337088dbca3435"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t alt_nand_spare_size_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of a page spare area in bytes.</p>
<p>Returns the size of a page spare area in bytes as read from the device during discovery and parameter configuration. For 512 byte devices this information typically has to be manually programmed by software.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the size of a page spare area in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="gae274321c5779321bfa29c7a3446c73fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool alt_nand_block_is_bad </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>block_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <b>true</b> if the specified device block is bad otherwise returns <b>false</b>.</p>
<p>Returns <b>true</b> if the specified device block is marked defective (i.e. bad) and should not be used. Otherwise the device block is assumed usable and <b>true</b> is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_addr</td><td>The block address to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><b>true</b> if the specified device block is bad otherwise returns <b>false</b>. </dd></dl>

</div>
</div>
<a class="anchor" id="gadd42b58de806ab8e3da97df0a1b55a50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_nand_bad_block_table_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga460791829165d67f155f73e4674b6f6c">alt_nand_bad_block_table_t</a>&#160;</td>
          <td class="paramname"><em>bad_block_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>bad_block_table_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a copy of the bad block table for the device.</p>
<p>Returns a copy of the bad block table for the device in a user specified buffer. The size and organization of the bad block table are described in <a class="el" href="group___a_l_t___n_a_n_d___f_l_a_s_h.html#ga460791829165d67f155f73e4674b6f6c">alt_nand_bad_block_table_t</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bad_block_table</td><td>[out] Pointer to a buffer of type alt_nand_bad_block_table_t to return a copy of the bad block table in.</td></tr>
    <tr><td class="paramname">bad_block_table_len</td><td>The length of the <em>bad_block_table</em> parameter in number of elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Indicates successful completion. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Indicates an error occurred. </td></tr>
    <tr><td class="paramname">ALT_E_BAD_ARG</td><td>The <em>bad_block_table_len</em> specifies a bad_block_table length that is not large enough to hold a copy of the bad block table for the device. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 13 2018 01:57:45 for Altera HWLIB by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
