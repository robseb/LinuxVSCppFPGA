<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Altera HWLIB: I2C Controller API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="altera-logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Altera HWLIB
   &#160;<span id="projectnumber">18.1</span>
   </div>
   <div id="projectbrief">The Altera HW Manager API Reference Manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Address&#160;Space</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group___a_l_t___i2_c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Members</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">ENUMS</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">I2C Controller API</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>This module defines an API for configuring and managing the HPS I2C controllers.</p>
<p>The I2C controller provides support for a communication link between integrated circuits on a board. It is a simple two-wire bus which consists of a serial data line (SDA) and a serial clock (SCL) for use in applications such as temperature sensors and voltage level translators to EEPROMs, A/D and D/A converters, CODECs, and many types of microprocessors.</p>
<p>The Hard Processor System (HPS) provides four I2C controllers to enable system software to communicate serially with I2C buses. Each I2C controller can operate in master or slave mode, and support standard mode of up to 100 kilobits per second (Kbps) or fast mode of up to 400 Kbps. These I2C controllers are instances of the Synopsys DesignWare APB I2C (DW_apb_i2c) controller.</p>
<p>NOTE: Each I2C controller must be programmed to operate in either master or slave mode only. Operating as a master and slave simultaneously is not supported.</p>
<p>Features of the I2C Controller:</p>
<ul>
<li>Support both 100 KBps and 400 KBps modes</li>
<li>One of the following I2C operations: master or slave</li>
<li>Support both 7-bit and 10-bit addressing modes</li>
<li>Mixed read and write combined-format transactions</li>
<li>Bulk transmit mode</li>
<li>DMA handshaking interface</li>
</ul>
<p>For a complete details on the configuration and operation of I2C controller, consult the following references:</p>
<ul>
<li><em>Cyclone V Device Handbook Volume 3: Hard Processor System Technical Reference Manual, Chapter 20. I2C Controller (cv_54020-1.2)</em></li>
<li><em>Synopsys DesignWare DW_apb_i2c Databook DW_apb_i2c, Version 1.15a</em></li>
<li><em>The I2C-Bus Specification Version 2.1</em> </li>
</ul>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Members</h2></td></tr>
<tr class="memitem:group___a_l_t___i2_c___s_d_a___h_o_l_d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c___s_d_a___h_o_l_d.html">SDA Hold Time Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___a_l_t___i2_c___g_e_n___c_a_l_l"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c___g_e_n___c_a_l_l.html">General Call</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___a_l_t___i2_c___i_n_t"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c___i_n_t.html">Interrupt and Status Conditions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___a_l_t___i2_c___r_x___f_i_f_o"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c___r_x___f_i_f_o.html">RX FIFO Management</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___a_l_t___i2_c___t_x___f_i_f_o"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c___t_x___f_i_f_o.html">TX FIFO Management</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___a_l_t___i2_c___d_m_a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c___d_m_a.html">DMA Interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s">ALT_I2C_MASTER_CONFIG_s</a></td></tr>
<tr class="separator:struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s">ALT_I2C_SLAVE_CONFIG_s</a></td></tr>
<tr class="separator:struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac5671984a2084fced59a4c2b55a80171"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gac5671984a2084fced59a4c2b55a80171">alt_i2c_cfg_to_speed</a>(i2c_dev, speed_in_hz, cfg)&#160;&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#ga90d8a89d7b447bede11a9c1c79ea3b99">alt_i2c_master_config_speed_get</a>((i2c_dev), (cfg), (speed_in_hz))</td></tr>
<tr class="separator:gac5671984a2084fced59a4c2b55a80171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ab3f8d3299c796d4c3624db67e4f79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga00ab3f8d3299c796d4c3624db67e4f79">alt_i2c_speed_to_cfg</a>(i2c_dev, speed_in_hz, cfg)&#160;&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gab7a9d3d9d126cce421b7a9e0254b2a6e">alt_i2c_master_config_speed_set</a>((i2c_dev), (cfg), (speed_in_hz))</td></tr>
<tr class="separator:ga00ab3f8d3299c796d4c3624db67e4f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab9525a902b2ee7ce1ffa4b8f99b75f42"><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="group___a_l_t___i2_c.html#gab45046fdc6d7cbe49fc048f26fd88719">ALT_I2C_TRANSFER_TYPE_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gab9525a902b2ee7ce1ffa4b8f99b75f42">ALT_I2C_TRANSFER_TYPE_t</a></td></tr>
<tr class="separator:gab9525a902b2ee7ce1ffa4b8f99b75f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db51a8ca7c78d287a620a1f894ba1c5"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga01201dba4856c4a6fcf418d24b5d809a">ALT_I2C_CTLR_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga1db51a8ca7c78d287a620a1f894ba1c5">ALT_I2C_CTLR_t</a></td></tr>
<tr class="separator:ga1db51a8ca7c78d287a620a1f894ba1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e9cb79693e43e74075112b2aebe1e2"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___a_l_t___i2_c.html#gacf173458ee847bebf75871c319aab2af">ALT_I2C_MODE_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga15e9cb79693e43e74075112b2aebe1e2">ALT_I2C_MODE_t</a></td></tr>
<tr class="separator:ga15e9cb79693e43e74075112b2aebe1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1601b0e27fb2a82170d10b4f6bdedbf6"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___a_l_t___i2_c.html#gad65b1b276561735ec5613ae1b1a000b7">ALT_I2C_SPEED_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga1601b0e27fb2a82170d10b4f6bdedbf6">ALT_I2C_SPEED_t</a></td></tr>
<tr class="separator:ga1601b0e27fb2a82170d10b4f6bdedbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf56449440abffe69a7941f24f9bf5b"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga9f24389b4997825c99f8e6f8846be810">ALT_I2C_ADDR_MODE_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gacaf56449440abffe69a7941f24f9bf5b">ALT_I2C_ADDR_MODE_t</a></td></tr>
<tr class="separator:gacaf56449440abffe69a7941f24f9bf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6fbc8f47536dd27035588f0ea138fe"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga229c6d995595615ca923ecc8b6490603">ALT_I2C_STATUS_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gaff6fbc8f47536dd27035588f0ea138fe">ALT_I2C_STATUS_t</a></td></tr>
<tr class="separator:gaff6fbc8f47536dd27035588f0ea138fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7ca3bb5e96b3425588a975987407738"><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="group___a_l_t___i2_c.html#ga321dbe61df714c442640f1c4a908aabf">ALT_I2C_TX_ABORT_CAUSE_e</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gae7ca3bb5e96b3425588a975987407738">ALT_I2C_TX_ABORT_CAUSE_t</a></td></tr>
<tr class="separator:gae7ca3bb5e96b3425588a975987407738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f317dbba3080bb537f6c145ca30d503"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="group___a_l_t___i2_c.html#struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s">ALT_I2C_MASTER_CONFIG_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a></td></tr>
<tr class="separator:ga4f317dbba3080bb537f6c145ca30d503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c0d22378cb1d6eb0194ca424026081d"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak"/>
<a class="el" href="group___a_l_t___i2_c.html#struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s">ALT_I2C_SLAVE_CONFIG_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga9c0d22378cb1d6eb0194ca424026081d">ALT_I2C_SLAVE_CONFIG_t</a></td></tr>
<tr class="separator:ga9c0d22378cb1d6eb0194ca424026081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
ENUMS</h2></td></tr>
<tr class="memitem:gab45046fdc6d7cbe49fc048f26fd88719"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gab45046fdc6d7cbe49fc048f26fd88719">ALT_I2C_TRANSFER_TYPE_e</a> { <br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#ggab45046fdc6d7cbe49fc048f26fd88719a32e4340e6199326b4a0f40551418e837">ALT_I2C_TRANSFER_NONE</a> = 0, 
<a class="el" href="group___a_l_t___i2_c.html#ggab45046fdc6d7cbe49fc048f26fd88719a7f39c16ecc9e2737eac47dc83af565d0">ALT_I2C_TRANSFER_START</a> = 1, 
<a class="el" href="group___a_l_t___i2_c.html#ggab45046fdc6d7cbe49fc048f26fd88719a6c8e61df90bd93935a0a6dfdd48e867a">ALT_I2C_TRANSFER_COMPLETE</a> = 2, 
<a class="el" href="group___a_l_t___i2_c.html#ggab45046fdc6d7cbe49fc048f26fd88719a277c5ca8aaa81a2e022183e783e36074">ALT_I2C_TRANSFER_READ</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#ggab45046fdc6d7cbe49fc048f26fd88719a3a187f7a87ec845a0fc43cf1351a3e8d">ALT_I2C_TRANSFER_WRITE</a> = 4
<br/>
 }</td></tr>
<tr class="separator:gab45046fdc6d7cbe49fc048f26fd88719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01201dba4856c4a6fcf418d24b5d809a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga01201dba4856c4a6fcf418d24b5d809a">ALT_I2C_CTLR_e</a> { <a class="el" href="group___a_l_t___i2_c.html#gga01201dba4856c4a6fcf418d24b5d809aa64db0ab02d64998354a9891bcd8a9bc4">ALT_I2C_I2C0</a> = (int)ALT_I2C0_OFST, 
<a class="el" href="group___a_l_t___i2_c.html#gga01201dba4856c4a6fcf418d24b5d809aa3bea8345403fdc1f2737f683d888139e">ALT_I2C_I2C1</a> = (int)ALT_I2C1_OFST
 }</td></tr>
<tr class="separator:ga01201dba4856c4a6fcf418d24b5d809a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf173458ee847bebf75871c319aab2af"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gacf173458ee847bebf75871c319aab2af">ALT_I2C_MODE_e</a> { <a class="el" href="group___a_l_t___i2_c.html#ggacf173458ee847bebf75871c319aab2afaa18ebb4c48e771eb6d6903223d308fa4">ALT_I2C_MODE_SLAVE</a> = ALT_I2C_CON_MST_MOD_E_DIS, 
<a class="el" href="group___a_l_t___i2_c.html#ggacf173458ee847bebf75871c319aab2afae4ef988cfcd5b3e534395b11ad7b58cd">ALT_I2C_MODE_MASTER</a> = ALT_I2C_CON_MST_MOD_E_EN
 }</td></tr>
<tr class="separator:gacf173458ee847bebf75871c319aab2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65b1b276561735ec5613ae1b1a000b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gad65b1b276561735ec5613ae1b1a000b7">ALT_I2C_SPEED_e</a> { <a class="el" href="group___a_l_t___i2_c.html#ggad65b1b276561735ec5613ae1b1a000b7a2e0a7aa944c0bafa0f02d474c672a6ab">ALT_I2C_SPEED_STANDARD</a> = ALT_I2C_CON_SPEED_E_STANDARD, 
<a class="el" href="group___a_l_t___i2_c.html#ggad65b1b276561735ec5613ae1b1a000b7a2981a6ba7691f5c26d60a5aa00bf5466">ALT_I2C_SPEED_FAST</a> = ALT_I2C_CON_SPEED_E_FAST
 }</td></tr>
<tr class="separator:gad65b1b276561735ec5613ae1b1a000b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f24389b4997825c99f8e6f8846be810"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga9f24389b4997825c99f8e6f8846be810">ALT_I2C_ADDR_MODE_e</a> { <a class="el" href="group___a_l_t___i2_c.html#gga9f24389b4997825c99f8e6f8846be810accff0afaa6849f1f5c2bc688b78670db">ALT_I2C_ADDR_MODE_7_BIT</a> = ALT_I2C_TAR_IC_10BITADDR_MST_E_START7, 
<a class="el" href="group___a_l_t___i2_c.html#gga9f24389b4997825c99f8e6f8846be810a7130f74072ffa24078e96f184689b8f5">ALT_I2C_ADDR_MODE_10_BIT</a> = ALT_I2C_TAR_IC_10BITADDR_MST_E_START10
 }</td></tr>
<tr class="separator:ga9f24389b4997825c99f8e6f8846be810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga229c6d995595615ca923ecc8b6490603"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga229c6d995595615ca923ecc8b6490603">ALT_I2C_STATUS_e</a> { <br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a90ca29e2de258befcec4c4164232a1f1">ALT_I2C_STATUS_RX_UNDER</a> = 1UL &lt;&lt; 0, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a22b0a9e0ff216b7cded5072d52987070">ALT_I2C_STATUS_RX_OVER</a> = 1UL &lt;&lt; 1, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603afa25a14f2647196a6d94dfe7f9e9db79">ALT_I2C_STATUS_RX_FULL</a> = 1UL &lt;&lt; 2, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a6f17bfac16b8a3b0fdd6702ce70a5434">ALT_I2C_STATUS_TX_OVER</a> = 1UL &lt;&lt; 3, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a83021f8b43d450947fed8f4be8d8440e">ALT_I2C_STATUS_TX_EMPTY</a> = 1UL &lt;&lt; 4, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603ac2e6202cb8a0e9cf804a1f6ca0dbc6d1">ALT_I2C_STATUS_RD_REQ</a> = 1UL &lt;&lt; 5, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a10730c376d727e9a7d7597bb61c3c296">ALT_I2C_STATUS_TX_ABORT</a> = 1UL &lt;&lt; 6, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603aa7e8235315c7d8adcceb16b35ef690a4">ALT_I2C_STATUS_RX_DONE</a> = 1UL &lt;&lt; 7, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a06d34863df76363170b3a9f7f31facbd">ALT_I2C_STATUS_ACTIVITY</a> = 1UL &lt;&lt; 8, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603ad2390f0db52489a6975f2302ef0dbd70">ALT_I2C_STATUS_STOP_DET</a> = 1UL &lt;&lt; 9, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603a0b6811cd6836045a64467646ecfc8a75">ALT_I2C_STATUS_START_DET</a> = 1UL &lt;&lt; 10, 
<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603ab1c1569f2060691e867c1a53ce578525">ALT_I2C_STATUS_INT_CALL</a> = 1UL &lt;&lt; 11, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga229c6d995595615ca923ecc8b6490603ab87517d404a73d013623aadecf758a7e">ALT_I2C_STATUS_INT_ALL</a> = 0xFFF
<br/>
 }</td></tr>
<tr class="separator:ga229c6d995595615ca923ecc8b6490603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga321dbe61df714c442640f1c4a908aabf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga321dbe61df714c442640f1c4a908aabf">ALT_I2C_TX_ABORT_CAUSE_e</a> { <br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfac605a53909853df1f2716fa4d39dc37e">ALT_I2C_TX_ABORT_CAUSE_7B_ADDR_NOACK</a> = 1UL &lt;&lt; 0, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa6447ffe2462fb7497d3c7f871aefc5da">ALT_I2C_TX_ABORT_CAUSE_10ADDR1_NOACK</a> = 1UL &lt;&lt; 1, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa0847428d94253dd2da2718bd8d1e9cd9">ALT_I2C_TX_ABORT_CAUSE_10ADDR2_NOACK</a> = 1UL &lt;&lt; 2, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa4e9b85d06d705de00829268fe9084c01">ALT_I2C_TX_ABORT_CAUSE_TXDATA_NOACK</a> = 1UL &lt;&lt; 3, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfae95b4faeccbc6c553ce8349e91c78b1b">ALT_I2C_TX_ABORT_CAUSE_GCALL_NOACK</a> = 1UL &lt;&lt; 4, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa300ccdfc227e05ebbdc13e13a4e6b10a">ALT_I2C_TX_ABORT_CAUSE_GCALL_RD</a> = 1UL &lt;&lt; 5, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa567f580663bb0c0b9578919177592bc9">ALT_I2C_TX_ABORT_CAUSE_HS_ACKDET</a> = 1UL &lt;&lt; 6, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfaa4ea377254b2ea42a730e51bc4b1120a">ALT_I2C_TX_ABORT_CAUSE_SBYTE_ACKDET</a> = 1UL &lt;&lt; 7, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa4dc74fc90f82604a35070f3425b58489">ALT_I2C_TX_ABORT_CAUSE_HS_NORSTRT</a> = 1UL &lt;&lt; 8, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa8c1f72561a9fd7229a5ab74b9b88286e">ALT_I2C_TX_ABORT_CAUSE_SBYTE_NORSTRT</a> = 1UL &lt;&lt; 9, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfafb17f88d06d808137c54de64568105d1">ALT_I2C_TX_ABORT_CAUSE_10B_RD_NORSTRT</a> = 1UL &lt;&lt; 10, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa20e4fdecb895ba70c89c9909dff0a77c">ALT_I2C_TX_ABORT_CAUSE_MST_DIS</a> = 1UL &lt;&lt; 11, 
<br/>
&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa40a64d4ca3b52c6e7f91cdf273cd0e49">ALT_I2C_TX_ABORT_CAUSE_ARB_LOST</a> = 1UL &lt;&lt; 12, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfac0c26aa1362ddfc9cc0bac1c67cca2fe">ALT_I2C_TX_ABORT_CAUSE_SLVFLUSH_TXFIFO</a> = 1UL &lt;&lt; 13, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa598fa279cf304f1ab3792ef9a17b4e01">ALT_I2C_TX_ABORT_CAUSE_SLV_ARBLOST</a> = 1UL &lt;&lt; 14, 
<a class="el" href="group___a_l_t___i2_c.html#gga321dbe61df714c442640f1c4a908aabfa2614ceb1001e929a135764323c823992">ALT_I2C_TX_ABORT_CAUSE_SLVRD_INTX</a> = 1UL &lt;&lt; 15
<br/>
 }</td></tr>
<tr class="separator:ga321dbe61df714c442640f1c4a908aabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6c4e543ed4ae5b99e8e2ff02eae463cc"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga6c4e543ed4ae5b99e8e2ff02eae463cc">alt_i2c_init</a> (const <a class="el" href="group___a_l_t___i2_c.html#ga1db51a8ca7c78d287a620a1f894ba1c5">ALT_I2C_CTLR_t</a> i2c, ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:ga6c4e543ed4ae5b99e8e2ff02eae463cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeabf95833cc757c3ff6315c13194777d"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gaeabf95833cc757c3ff6315c13194777d">alt_i2c_reset</a> (ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:gaeabf95833cc757c3ff6315c13194777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7cc51922c0e90eb3695c4757fb7eba3"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gae7cc51922c0e90eb3695c4757fb7eba3">alt_i2c_uninit</a> (ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:gae7cc51922c0e90eb3695c4757fb7eba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad16c19c9abacbfbe6f4501b0db490322"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gad16c19c9abacbfbe6f4501b0db490322">alt_i2c_disable</a> (ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:gad16c19c9abacbfbe6f4501b0db490322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60c931e6e918b963313fc729c5418289"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga60c931e6e918b963313fc729c5418289">alt_i2c_enable</a> (ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:ga60c931e6e918b963313fc729c5418289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga766698352e55a0abdf158be06c7faed1"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga766698352e55a0abdf158be06c7faed1">alt_i2c_is_enabled</a> (ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:ga766698352e55a0abdf158be06c7faed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33fc9aa9f017d7ae7eb0779415e9d69f"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga33fc9aa9f017d7ae7eb0779415e9d69f">alt_i2c_master_config_get</a> (ALT_I2C_DEV_t *i2c_dev, <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *cfg)</td></tr>
<tr class="separator:ga33fc9aa9f017d7ae7eb0779415e9d69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1e81c86d394a6cc962598e3e32931d5"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gae1e81c86d394a6cc962598e3e32931d5">alt_i2c_master_config_set</a> (ALT_I2C_DEV_t *i2c_dev, const <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *cfg)</td></tr>
<tr class="separator:gae1e81c86d394a6cc962598e3e32931d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90d8a89d7b447bede11a9c1c79ea3b99"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga90d8a89d7b447bede11a9c1c79ea3b99">alt_i2c_master_config_speed_get</a> (ALT_I2C_DEV_t *i2c_dev, const <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *cfg, uint32_t *speed_in_hz)</td></tr>
<tr class="separator:ga90d8a89d7b447bede11a9c1c79ea3b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7a9d3d9d126cce421b7a9e0254b2a6e"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gab7a9d3d9d126cce421b7a9e0254b2a6e">alt_i2c_master_config_speed_set</a> (ALT_I2C_DEV_t *i2c_dev, <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *cfg, uint32_t speed_in_hz)</td></tr>
<tr class="separator:gab7a9d3d9d126cce421b7a9e0254b2a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2db2575ff493909f71d05f9aa37848b6"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga2db2575ff493909f71d05f9aa37848b6">alt_i2c_slave_config_get</a> (ALT_I2C_DEV_t *i2c_dev, <a class="el" href="group___a_l_t___i2_c.html#ga9c0d22378cb1d6eb0194ca424026081d">ALT_I2C_SLAVE_CONFIG_t</a> *cfg)</td></tr>
<tr class="separator:ga2db2575ff493909f71d05f9aa37848b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11d526a49799f04d8f5336bce0dde18"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gaf11d526a49799f04d8f5336bce0dde18">alt_i2c_slave_config_set</a> (ALT_I2C_DEV_t *i2c_dev, const <a class="el" href="group___a_l_t___i2_c.html#ga9c0d22378cb1d6eb0194ca424026081d">ALT_I2C_SLAVE_CONFIG_t</a> *cfg)</td></tr>
<tr class="separator:gaf11d526a49799f04d8f5336bce0dde18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga422d03c04681a4c27b1894ffe133213c"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga422d03c04681a4c27b1894ffe133213c">alt_i2c_op_mode_get</a> (ALT_I2C_DEV_t *i2c_dev, <a class="el" href="group___a_l_t___i2_c.html#ga15e9cb79693e43e74075112b2aebe1e2">ALT_I2C_MODE_t</a> *<a class="el" href="alt__spi_8h.html#a884373a2516c13dbc5e31fd64dea6eab">mode</a>)</td></tr>
<tr class="separator:ga422d03c04681a4c27b1894ffe133213c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc79f16589bc6e18cfa6841d316c8109"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gafc79f16589bc6e18cfa6841d316c8109">alt_i2c_op_mode_set</a> (ALT_I2C_DEV_t *i2c_dev, const <a class="el" href="group___a_l_t___i2_c.html#ga15e9cb79693e43e74075112b2aebe1e2">ALT_I2C_MODE_t</a> <a class="el" href="alt__spi_8h.html#a884373a2516c13dbc5e31fd64dea6eab">mode</a>)</td></tr>
<tr class="separator:gafc79f16589bc6e18cfa6841d316c8109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511834bf99afd6c808d4fdc593a40bde"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga511834bf99afd6c808d4fdc593a40bde">alt_i2c_is_busy</a> (ALT_I2C_DEV_t *i2c_dev)</td></tr>
<tr class="separator:ga511834bf99afd6c808d4fdc593a40bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fef6676a5473f870bf441d29932239b"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga4fef6676a5473f870bf441d29932239b">alt_i2c_read</a> (ALT_I2C_DEV_t *i2c_dev, uint8_t *val)</td></tr>
<tr class="separator:ga4fef6676a5473f870bf441d29932239b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22c701c3cecc56086156a0cde75277ef"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga22c701c3cecc56086156a0cde75277ef">alt_i2c_write</a> (ALT_I2C_DEV_t *i2c_dev, const uint8_t val)</td></tr>
<tr class="separator:ga22c701c3cecc56086156a0cde75277ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadba976480855d6b962cd0abbdb01c42"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gaadba976480855d6b962cd0abbdb01c42">alt_i2c_slave_receive</a> (ALT_I2C_DEV_t *i2c_dev, uint8_t *data)</td></tr>
<tr class="separator:gaadba976480855d6b962cd0abbdb01c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3137e57044cb1f6d1b8ce9b09baf61e3"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga3137e57044cb1f6d1b8ce9b09baf61e3">alt_i2c_slave_transmit</a> (ALT_I2C_DEV_t *i2c_dev, const uint8_t data)</td></tr>
<tr class="separator:ga3137e57044cb1f6d1b8ce9b09baf61e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0328c19c0b8da8349533947b15ae291d"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga0328c19c0b8da8349533947b15ae291d">alt_i2c_slave_bulk_transmit</a> (ALT_I2C_DEV_t *i2c_dev, const void *data, const size_t size)</td></tr>
<tr class="separator:ga0328c19c0b8da8349533947b15ae291d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24c8832ba8eb5643a4455adfaf48b3c"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gaa24c8832ba8eb5643a4455adfaf48b3c">alt_i2c_master_target_get</a> (ALT_I2C_DEV_t *i2c_dev, uint32_t *target_addr)</td></tr>
<tr class="separator:gaa24c8832ba8eb5643a4455adfaf48b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9069f423699fb1a1a7ba60ce524a8320"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga9069f423699fb1a1a7ba60ce524a8320">alt_i2c_master_target_set</a> (ALT_I2C_DEV_t *i2c_dev, uint32_t target_addr)</td></tr>
<tr class="separator:ga9069f423699fb1a1a7ba60ce524a8320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed6d67ba8f5200395f72d89bae1bb0c0"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gaed6d67ba8f5200395f72d89bae1bb0c0">alt_i2c_master_transmit</a> (ALT_I2C_DEV_t *i2c_dev, const void *data, const size_t size, const uint8_t issue_restart, const uint8_t issue_stop)</td></tr>
<tr class="separator:gaed6d67ba8f5200395f72d89bae1bb0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab88766a82c41e49ba2802ac482aa7e44"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#gab88766a82c41e49ba2802ac482aa7e44">alt_i2c_master_receive</a> (ALT_I2C_DEV_t *i2c_dev, void *data, const size_t size, const uint8_t issue_restart, const uint8_t issue_stop)</td></tr>
<tr class="separator:gab88766a82c41e49ba2802ac482aa7e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26da61779581c9bb4b6f64c59c355e13"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga26da61779581c9bb4b6f64c59c355e13">alt_i2c_issue_read</a> (ALT_I2C_DEV_t *i2c_dev, const uint8_t issue_restart, const uint8_t issue_stop)</td></tr>
<tr class="separator:ga26da61779581c9bb4b6f64c59c355e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04427056d32e48df6a386a645bc5df91"><td class="memItemLeft" align="right" valign="top">ALT_STATUS_CODE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_l_t___i2_c.html#ga04427056d32e48df6a386a645bc5df91">alt_i2c_issue_write</a> (ALT_I2C_DEV_t *i2c_dev, const uint8_t value, const uint8_t issue_restart, const uint8_t issue_stop)</td></tr>
<tr class="separator:ga04427056d32e48df6a386a645bc5df91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s" id="struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ALT_I2C_MASTER_CONFIG_s</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This type defines a structure for configuration of the SCL high and low counts to ensure proper I/O timing with the device interface.</p>
<p>The SCL count values are only relevant if the I2C controller is enabled to as an I2C master. The SCL count values are ignored when the I2C controller is enabled as an I2C slave.</p>
<p>See: Clock Frequency Configuration section of <em>Chapter 20. I2C Controller</em> in the <em>Cyclone V Device Handbook Volume 3: Hard Processor System Technical Reference Manual</em> for a complete discussion of calculation of the proper SCL clock high and low times. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a921c0ba4fc75b0cf621075eb419a20d1"></a><a class="el" href="group___a_l_t___i2_c.html#gacaf56449440abffe69a7941f24f9bf5b">ALT_I2C_ADDR_MODE_t</a></td>
<td class="fieldname">
addr_mode</td>
<td class="fielddoc">
The address mode (7 or 10 bit) when acting as a master. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="afa8cf8515c0459c235eb5ebc11bf9475"></a>uint8_t</td>
<td class="fieldname">
restart_enable</td>
<td class="fielddoc">
This setting determines whether RESTART conditions may be sent when acting as a master. When the <em>restart_enable</em> is false, the I2C controller master is incapable of performing the following functions:</p>
<ul>
<li>Sending a START BYTE</li>
<li>Performing any high-speed mode operation</li>
<li>Performing direction changes in combined format mode</li>
<li>Performing a read operation with a 10-bit address </li>
</ul>
</td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4f335cf08b9832cf923796860f09bd05"></a><a class="el" href="group___a_l_t___i2_c.html#ga1601b0e27fb2a82170d10b4f6bdedbf6">ALT_I2C_SPEED_t</a></td>
<td class="fieldname">
speed_mode</td>
<td class="fielddoc">
The speed mode of the I2C operation. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a2c2147d744d76fa6df10232eecb097fa"></a>uint16_t</td>
<td class="fieldname">
ss_scl_hcnt</td>
<td class="fielddoc">
The SCL clock high-period count for standard speed. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a42a8443ec6e4f7524c0cc6b5c58d676e"></a>uint16_t</td>
<td class="fieldname">
ss_scl_lcnt</td>
<td class="fielddoc">
The SCL clock low-period count for standard speed. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a58f4621200f41b649d45bb5fbd9ae8ca"></a>uint16_t</td>
<td class="fieldname">
fs_scl_hcnt</td>
<td class="fielddoc">
The SCL clock high-period count for fast speed. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="ae9010068db86d57b4c0b1a6159753c57"></a>uint16_t</td>
<td class="fieldname">
fs_scl_lcnt</td>
<td class="fielddoc">
The SCL clock low-period count for fast speed. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aa453abc962f00a779d23150799c9be9d"></a>uint8_t</td>
<td class="fieldname">
fs_spklen</td>
<td class="fielddoc">
The duration, measured in ic_clk cycles, of the longest spike that is filtered out by the spike suppression logic when the component is operating in SS or FS modes. </td></tr>
</table>

</div>
</div>
<a name="struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s" id="struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct ALT_I2C_SLAVE_CONFIG_s</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>This type defines a structure for configuration of the I2C controller when it is operating in slave mode. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a4144df0aacaf384eecee950ff8f903a1"></a><a class="el" href="group___a_l_t___i2_c.html#gacaf56449440abffe69a7941f24f9bf5b">ALT_I2C_ADDR_MODE_t</a></td>
<td class="fieldname">
addr_mode</td>
<td class="fielddoc">
The address mode (7 or 10 bit) when acting as a slave. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9e33d2fc1b3fd174271728fab20cf40f"></a>uint32_t</td>
<td class="fieldname">
addr</td>
<td class="fielddoc">
The slave address to which the I2C controller responds when acting as a slave. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a623a9467b42109fc620ad939b4e8b144"></a>uint8_t</td>
<td class="fieldname">
nack_enable</td>
<td class="fielddoc">
Enable generation of a NACK. when the I2C controller is a slave-receiver. If <b>true</b>, it can only generate a NACK after a data byte is received; hence, the data transfer is aborted and the data received is not pushed onto the receive buffer. When <b>false</b>, it generates NACK/ACK, depending on normal criteria.</p>
<ul>
<li><b>true</b> = generate NACK after data byte received</li>
<li><b>false</b> = generate NACK/ACK normally </li>
</ul>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definitions</h2>
<a class="anchor" id="gac5671984a2084fced59a4c2b55a80171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alt_i2c_cfg_to_speed</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i2c_dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">speed_in_hz, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cfg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#ga90d8a89d7b447bede11a9c1c79ea3b99">alt_i2c_master_config_speed_get</a>((i2c_dev), (cfg), (speed_in_hz))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definition included for backwards compatibility. </p>

</div>
</div>
<a class="anchor" id="ga00ab3f8d3299c796d4c3624db67e4f79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define alt_i2c_speed_to_cfg</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i2c_dev, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">speed_in_hz, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">cfg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="group___a_l_t___i2_c.html#gab7a9d3d9d126cce421b7a9e0254b2a6e">alt_i2c_master_config_speed_set</a>((i2c_dev), (cfg), (speed_in_hz))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definition included for backwards compatibility. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gab9525a902b2ee7ce1ffa4b8f99b75f42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#gab45046fdc6d7cbe49fc048f26fd88719">ALT_I2C_TRANSFER_TYPE_e</a>
 <a class="el" href="group___a_l_t___i2_c.html#gab9525a902b2ee7ce1ffa4b8f99b75f42">ALT_I2C_TRANSFER_TYPE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type definition enumerates the operational state of I2C by transfer operation. </p>

</div>
</div>
<a class="anchor" id="ga1db51a8ca7c78d287a620a1f894ba1c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga01201dba4856c4a6fcf418d24b5d809a">ALT_I2C_CTLR_e</a>  <a class="el" href="group___a_l_t___i2_c.html#ga1db51a8ca7c78d287a620a1f894ba1c5">ALT_I2C_CTLR_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the HPS I2C controller instances. </p>

</div>
</div>
<a class="anchor" id="ga15e9cb79693e43e74075112b2aebe1e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#gacf173458ee847bebf75871c319aab2af">ALT_I2C_MODE_e</a>  <a class="el" href="group___a_l_t___i2_c.html#ga15e9cb79693e43e74075112b2aebe1e2">ALT_I2C_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the modes that the I2C controller may operate in.</p>
<p>NOTE: Each I2C controller must be programmed to operate in either master or slave mode only. Operating as a master and slave simultaneously is not supported. </p>

</div>
</div>
<a class="anchor" id="ga1601b0e27fb2a82170d10b4f6bdedbf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#gad65b1b276561735ec5613ae1b1a000b7">ALT_I2C_SPEED_e</a>  <a class="el" href="group___a_l_t___i2_c.html#ga1601b0e27fb2a82170d10b4f6bdedbf6">ALT_I2C_SPEED_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the I2C controller operational speed modes.</p>
<p>The I2C controller can operate in standard mode (with data rates 0 to 100 Kbps) or fast mode (with data rates less than or equal to 400 Kbps). Additionally, fast mode devices are downward compatible. For instance, fast mode devices can communicate with standard mode devices in 0 to 100 Kbps I2C bus system. However, standard mode devices are not upward compatible and should not be incorporated in a fast-mode I2C bus system as they cannot follow the higher transfer rate and therefore unpredictable states would occur.</p>
<p>This setting is relevant only if one is operating the I2C in master mode. </p>

</div>
</div>
<a class="anchor" id="gacaf56449440abffe69a7941f24f9bf5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga9f24389b4997825c99f8e6f8846be810">ALT_I2C_ADDR_MODE_e</a>  <a class="el" href="group___a_l_t___i2_c.html#gacaf56449440abffe69a7941f24f9bf5b">ALT_I2C_ADDR_MODE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the two addressing modes formats supported by the I2C controller.</p>
<p>The I2C controller does not support mixed address format - that is, a 7-bit address transaction followed by a 10-bit address transaction or vice versa - combined format transactions. </p>

</div>
</div>
<a class="anchor" id="gaff6fbc8f47536dd27035588f0ea138fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga229c6d995595615ca923ecc8b6490603">ALT_I2C_STATUS_e</a>  <a class="el" href="group___a_l_t___i2_c.html#gaff6fbc8f47536dd27035588f0ea138fe">ALT_I2C_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates interrupt status conditions for the I2C controller. </p>

</div>
</div>
<a class="anchor" id="gae7ca3bb5e96b3425588a975987407738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___a_l_t___i2_c.html#ga321dbe61df714c442640f1c4a908aabf">ALT_I2C_TX_ABORT_CAUSE_e</a>  <a class="el" href="group___a_l_t___i2_c.html#gae7ca3bb5e96b3425588a975987407738">ALT_I2C_TX_ABORT_CAUSE_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the source causes of a ALT_I2C_STATUS_TX_ABORT condition.</p>
<p>The active ALT_I2C_TX_ABORT_CAUSE_t source conditions are cleared when <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with is called ALT_I2C_STATUS_TX_ABORT in the mask or <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> is called with ALT_I2C_STATUS_ALL in the mask. </p>

</div>
</div>
<a class="anchor" id="ga4f317dbba3080bb537f6c145ca30d503"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___a_l_t___i2_c.html#struct_a_l_t___i2_c___m_a_s_t_e_r___c_o_n_f_i_g__s">ALT_I2C_MASTER_CONFIG_s</a>  <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type defines a structure for configuration of the SCL high and low counts to ensure proper I/O timing with the device interface.</p>
<p>The SCL count values are only relevant if the I2C controller is enabled to as an I2C master. The SCL count values are ignored when the I2C controller is enabled as an I2C slave.</p>
<p>See: Clock Frequency Configuration section of <em>Chapter 20. I2C Controller</em> in the <em>Cyclone V Device Handbook Volume 3: Hard Processor System Technical Reference Manual</em> for a complete discussion of calculation of the proper SCL clock high and low times. </p>

</div>
</div>
<a class="anchor" id="ga9c0d22378cb1d6eb0194ca424026081d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___a_l_t___i2_c.html#struct_a_l_t___i2_c___s_l_a_v_e___c_o_n_f_i_g__s">ALT_I2C_SLAVE_CONFIG_s</a>  <a class="el" href="group___a_l_t___i2_c.html#ga9c0d22378cb1d6eb0194ca424026081d">ALT_I2C_SLAVE_CONFIG_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type defines a structure for configuration of the I2C controller when it is operating in slave mode. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gab45046fdc6d7cbe49fc048f26fd88719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#gab45046fdc6d7cbe49fc048f26fd88719">ALT_I2C_TRANSFER_TYPE_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type definition enumerates the operational state of I2C by transfer operation. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab45046fdc6d7cbe49fc048f26fd88719a32e4340e6199326b4a0f40551418e837"></a>ALT_I2C_TRANSFER_NONE</em>&nbsp;</td><td>
<p>No transfer operation </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab45046fdc6d7cbe49fc048f26fd88719a7f39c16ecc9e2737eac47dc83af565d0"></a>ALT_I2C_TRANSFER_START</em>&nbsp;</td><td>
<p>Start detect </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab45046fdc6d7cbe49fc048f26fd88719a6c8e61df90bd93935a0a6dfdd48e867a"></a>ALT_I2C_TRANSFER_COMPLETE</em>&nbsp;</td><td>
<p>All operations done </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab45046fdc6d7cbe49fc048f26fd88719a277c5ca8aaa81a2e022183e783e36074"></a>ALT_I2C_TRANSFER_READ</em>&nbsp;</td><td>
<p>Read operation is active </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab45046fdc6d7cbe49fc048f26fd88719a3a187f7a87ec845a0fc43cf1351a3e8d"></a>ALT_I2C_TRANSFER_WRITE</em>&nbsp;</td><td>
<p>Write operation is active </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga01201dba4856c4a6fcf418d24b5d809a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#ga01201dba4856c4a6fcf418d24b5d809a">ALT_I2C_CTLR_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the HPS I2C controller instances. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga01201dba4856c4a6fcf418d24b5d809aa64db0ab02d64998354a9891bcd8a9bc4"></a>ALT_I2C_I2C0</em>&nbsp;</td><td>
<p>I2C0 instance. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga01201dba4856c4a6fcf418d24b5d809aa3bea8345403fdc1f2737f683d888139e"></a>ALT_I2C_I2C1</em>&nbsp;</td><td>
<p>I2C1 instance. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf173458ee847bebf75871c319aab2af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#gacf173458ee847bebf75871c319aab2af">ALT_I2C_MODE_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the modes that the I2C controller may operate in.</p>
<p>NOTE: Each I2C controller must be programmed to operate in either master or slave mode only. Operating as a master and slave simultaneously is not supported. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggacf173458ee847bebf75871c319aab2afaa18ebb4c48e771eb6d6903223d308fa4"></a>ALT_I2C_MODE_SLAVE</em>&nbsp;</td><td>
<p>Slave Mode </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggacf173458ee847bebf75871c319aab2afae4ef988cfcd5b3e534395b11ad7b58cd"></a>ALT_I2C_MODE_MASTER</em>&nbsp;</td><td>
<p>Master Mode </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gad65b1b276561735ec5613ae1b1a000b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#gad65b1b276561735ec5613ae1b1a000b7">ALT_I2C_SPEED_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the I2C controller operational speed modes.</p>
<p>The I2C controller can operate in standard mode (with data rates 0 to 100 Kbps) or fast mode (with data rates less than or equal to 400 Kbps). Additionally, fast mode devices are downward compatible. For instance, fast mode devices can communicate with standard mode devices in 0 to 100 Kbps I2C bus system. However, standard mode devices are not upward compatible and should not be incorporated in a fast-mode I2C bus system as they cannot follow the higher transfer rate and therefore unpredictable states would occur.</p>
<p>This setting is relevant only if one is operating the I2C in master mode. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggad65b1b276561735ec5613ae1b1a000b7a2e0a7aa944c0bafa0f02d474c672a6ab"></a>ALT_I2C_SPEED_STANDARD</em>&nbsp;</td><td>
<p>Standard mode (0 to 100 Kbps) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggad65b1b276561735ec5613ae1b1a000b7a2981a6ba7691f5c26d60a5aa00bf5466"></a>ALT_I2C_SPEED_FAST</em>&nbsp;</td><td>
<p>Fast mode (&lt;= 400 Kbps) </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f24389b4997825c99f8e6f8846be810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#ga9f24389b4997825c99f8e6f8846be810">ALT_I2C_ADDR_MODE_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the two addressing modes formats supported by the I2C controller.</p>
<p>The I2C controller does not support mixed address format - that is, a 7-bit address transaction followed by a 10-bit address transaction or vice versa - combined format transactions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9f24389b4997825c99f8e6f8846be810accff0afaa6849f1f5c2bc688b78670db"></a>ALT_I2C_ADDR_MODE_7_BIT</em>&nbsp;</td><td>
<p>7-Bit Address Format </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9f24389b4997825c99f8e6f8846be810a7130f74072ffa24078e96f184689b8f5"></a>ALT_I2C_ADDR_MODE_10_BIT</em>&nbsp;</td><td>
<p>10-Bit Address Format </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga229c6d995595615ca923ecc8b6490603"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#ga229c6d995595615ca923ecc8b6490603">ALT_I2C_STATUS_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates interrupt status conditions for the I2C controller. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a90ca29e2de258befcec4c4164232a1f1"></a>ALT_I2C_STATUS_RX_UNDER</em>&nbsp;</td><td>
<p>Set if the processor attempts to read the receive buffer when it is empty. If the I2C controller is disabled, this status keeps maintains its state until the master or slave state machines go into idle, then this interrupt is cleared. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a22b0a9e0ff216b7cded5072d52987070"></a>ALT_I2C_STATUS_RX_OVER</em>&nbsp;</td><td>
<p>Set if the receive buffer is completely filled to capacity and an additional byte is received from an external I2C device. The I2C controller acknowledges this, but any data bytes received after the FIFO is full are discarded. If the I2C controller is disabled, this status maintains its statue until the master or slave state machines go into idle, then this interrupt is cleared. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603afa25a14f2647196a6d94dfe7f9e9db79"></a>ALT_I2C_STATUS_RX_FULL</em>&nbsp;</td><td>
<p>Set when the receive buffer reaches or goes above the RX_TL threshold. It is automatically cleared by hardware when buffer level goes below the threshold. If the I2C controller is disabled, the RX FIFO is flushed and held in reset; therefore the RX FIFO is not full. So this bit is cleared once the I2C controller is disabled, regardless of the activity that continues. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a6f17bfac16b8a3b0fdd6702ce70a5434"></a>ALT_I2C_STATUS_TX_OVER</em>&nbsp;</td><td>
<p>Set during transmit if the transmit buffer is filled to capacity and the processor attempts to issue another I2C command. When the I2C controller is disabled, this bit maintains its state until the master or slave state machines go into idle, then this interrupt is cleared. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a83021f8b43d450947fed8f4be8d8440e"></a>ALT_I2C_STATUS_TX_EMPTY</em>&nbsp;</td><td>
<p>This bit is set to 1 when the transmit buffer is at or below the configured threshold value. It is automatically cleared by hardware when the buffer level goes above the threshold. When the I2C controller is disabled, the TX FIFO is flushed and held in reset. The TX FIFO appears as if it has no data in it, so this bit is set to 1, provided there is activity in the master or slave state machines. When there is no longer activity, then this bit is set to 0. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603ac2e6202cb8a0e9cf804a1f6ca0dbc6d1"></a>ALT_I2C_STATUS_RD_REQ</em>&nbsp;</td><td>
<p>This bit is set to 1 when I2C is acting as a slave and another I2C master is attempting to read data from the I2C. The I2C holds the bus in a wait state until this interrupt is serviced, which means that the slave has been addressed by a remote master that is asking for data to be transferred. The processor must respond to this interrupt and then write the requested data. This bit is set to 0 just after the processor by calling <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with ALT_I2C_STATUS_RD_REQ in the mask.. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a10730c376d727e9a7d7597bb61c3c296"></a>ALT_I2C_STATUS_TX_ABORT</em>&nbsp;</td><td>
<p>This bit indicates if I2C, as an I2C transmitter, is unable to complete the intended actions on the contents of the transmit FIFO. This situation can occur both as an I2C master or an I2C slave, and is referred to as a 'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort takes places.</p>
<p>NOTE: The I2C flushes/resets/empties the TX FIFO whenever this bit is set. The TX FIFO remains in this flushed state until the register <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with ALT_I2C_STATUS_TX_ABORT in the mask is called. Once this happens, the TX FIFO is then ready to accept more data bytes from the APB interface. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603aa7e8235315c7d8adcceb16b35ef690a4"></a>ALT_I2C_STATUS_RX_DONE</em>&nbsp;</td><td>
<p>When the I2C is acting as a slave-transmitter, this bit is set to 1 if the master does not acknowledge a transmitted byte. This occurs on the last byte of the transmission, indicating that the transmission is done. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a06d34863df76363170b3a9f7f31facbd"></a>ALT_I2C_STATUS_ACTIVITY</em>&nbsp;</td><td>
<p>This bit captures I2C activity and stays set until it is cleared. There are four ways to clear it:</p>
<ul>
<li>Disabling the I2C controller</li>
<li>Calling <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with ALT_I2C_STATUS_ACTIVITY in the mask.</li>
<li>Calling <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with ALT_I2C_STATUS_ALL in the mask.</li>
<li>System reset</li>
</ul>
<p>Once this bit is set, it stays set unless one of the four methods is used to clear it. Even if the I2C module is idle, this bit remains set until cleared, indicating that there was activity on the bus. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603ad2390f0db52489a6975f2302ef0dbd70"></a>ALT_I2C_STATUS_STOP_DET</em>&nbsp;</td><td>
<p>Indicates whether a STOP condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603a0b6811cd6836045a64467646ecfc8a75"></a>ALT_I2C_STATUS_START_DET</em>&nbsp;</td><td>
<p>Indicates whether a START or RESTART condition has occurred on the I2C interface regardless of whether I2C is operating in slave or master mode. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603ab1c1569f2060691e867c1a53ce578525"></a>ALT_I2C_STATUS_INT_CALL</em>&nbsp;</td><td>
<p>Set only when a General Call address is received and it is acknowledged. It stays set until it is cleared either by disabling I2C or when <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with ALT_I2C_STATUS_CALL in the mask is called. I2C stores the received data in the Rx buffer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga229c6d995595615ca923ecc8b6490603ab87517d404a73d013623aadecf758a7e"></a>ALT_I2C_STATUS_INT_ALL</em>&nbsp;</td><td>
<p>All Combined and Individual Interrupts. This enumeration value can be used to clear, disable, and enable the combined interrupt and all individual interrupt status conditions. As a side effect, when passed to <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a>, clears the source causes (<a class="el" href="group___a_l_t___i2_c.html#gae7ca3bb5e96b3425588a975987407738">ALT_I2C_TX_ABORT_CAUSE_t</a>) of the ALT_I2C_STATUS_TX_ABORT condition. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga321dbe61df714c442640f1c4a908aabf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_l_t___i2_c.html#ga321dbe61df714c442640f1c4a908aabf">ALT_I2C_TX_ABORT_CAUSE_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type enumerates the source causes of a ALT_I2C_STATUS_TX_ABORT condition.</p>
<p>The active ALT_I2C_TX_ABORT_CAUSE_t source conditions are cleared when <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> with is called ALT_I2C_STATUS_TX_ABORT in the mask or <a class="el" href="group___a_l_t___i2_c___i_n_t.html#gae00500b27051a82ff75905e777f0e1c8">alt_i2c_int_clear()</a> is called with ALT_I2C_STATUS_ALL in the mask. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfac605a53909853df1f2716fa4d39dc37e"></a>ALT_I2C_TX_ABORT_CAUSE_7B_ADDR_NOACK</em>&nbsp;</td><td>
<p>Master Abort 7 Bit Address - If set (1), Master is in 7-bit addressing mode and the address sent was not acknowledged by any slave.</p>
<p>Role of I2C: Master-Transmitter or Master-Receiver </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa6447ffe2462fb7497d3c7f871aefc5da"></a>ALT_I2C_TX_ABORT_CAUSE_10ADDR1_NOACK</em>&nbsp;</td><td>
<p>Master Abort 10 Bit Address Byte 1 - If set (1), Master is in 10-bit address mode and the first 10-bit address byte was not acknowledged by any slave.</p>
<p>Role of I2C: Master-Transmitter or Master-Receiver </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa0847428d94253dd2da2718bd8d1e9cd9"></a>ALT_I2C_TX_ABORT_CAUSE_10ADDR2_NOACK</em>&nbsp;</td><td>
<p>Master Abort 10 Bit Address Byte 2 - If set (1), Master is in 10-bit address mode and the second address byte of the 10-bit address was not acknowledged by any slave</p>
<p>Role of I2C: Master-Transmitter or Master-Receiver </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa4e9b85d06d705de00829268fe9084c01"></a>ALT_I2C_TX_ABORT_CAUSE_TXDATA_NOACK</em>&nbsp;</td><td>
<p>Master Abort TX NOACK Bit - If set (1), Master has received an acknowledgement for the address, but when it sent data byte(s) following the address, it did not receive an acknowledge from the remote slave(s). This is a master-mode only bit.</p>
<p>Role of I2C: Master-Transmitter. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfae95b4faeccbc6c553ce8349e91c78b1b"></a>ALT_I2C_TX_ABORT_CAUSE_GCALL_NOACK</em>&nbsp;</td><td>
<p>Master Abort GC Noack Bit - If set (1), I2C controller in master mode sent a General Call and no slave on the bus acknowledged the General Call.</p>
<p>Role of I2C: Master-Transmitter. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa300ccdfc227e05ebbdc13e13a4e6b10a"></a>ALT_I2C_TX_ABORT_CAUSE_GCALL_RD</em>&nbsp;</td><td>
<p>Master Abort GC Read Bit - If set (1), I2C controller in master mode sent a General Call but the user programmed the byte following the General Call to be a read from the bus (IC_DATA_CMD[9] is set to 1).</p>
<p>Role of I2C: Master-Transmitter. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa567f580663bb0c0b9578919177592bc9"></a>ALT_I2C_TX_ABORT_CAUSE_HS_ACKDET</em>&nbsp;</td><td>
<p>Master HS MC Ack - If set (1), Master is in High Speed mode and the High Speed Master code was acknowledged (wrong behavior).</p>
<p>Role of I2C: Master. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfaa4ea377254b2ea42a730e51bc4b1120a"></a>ALT_I2C_TX_ABORT_CAUSE_SBYTE_ACKDET</em>&nbsp;</td><td>
<p>Master Abort START Byte - If set (1), Master has sent a START Byte and the START Byte was acknowledged (wrong behavior).</p>
<p>Role of I2C: Master. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa4dc74fc90f82604a35070f3425b58489"></a>ALT_I2C_TX_ABORT_CAUSE_HS_NORSTRT</em>&nbsp;</td><td>
<p>Master HS Restart Disabled - If set (1), the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) = 0) and the user is trying to use the master to transfer data in High Speed mode.</p>
<p>Role of I2C: Master-Transmitter or Master-Receiver </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa8c1f72561a9fd7229a5ab74b9b88286e"></a>ALT_I2C_TX_ABORT_CAUSE_SBYTE_NORSTRT</em>&nbsp;</td><td>
<p>Master Abort START No Restart - To clear, the source of the ABRT_SBYTE_NORSTRT must be fixed first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared in the same manner as other bits in this register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear this bit, bit 9 clears for one cycle and then gets re-asserted.</p>
<p>If set (1), the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) = 0) and the user is trying to send a START Byte.</p>
<p>Role of I2C: Master. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfafb17f88d06d808137c54de64568105d1"></a>ALT_I2C_TX_ABORT_CAUSE_10B_RD_NORSTRT</em>&nbsp;</td><td>
<p>Master Abort 10 Bit No Restart - If set (1), the restart is disabled (IC_RESTART_EN bit (IC_CON[5]) = 0) and the master sends a read command in 10-bit addressing mode.</p>
<p>Role of I2C: Master Receiver. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa20e4fdecb895ba70c89c9909dff0a77c"></a>ALT_I2C_TX_ABORT_CAUSE_MST_DIS</em>&nbsp;</td><td>
<p>Master Operation with Master Disabled - If set (1), user tries to initiate a Master operation with the Master mode disabled.</p>
<p>Role of I2C: Master or Slave-Receiver. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa40a64d4ca3b52c6e7f91cdf273cd0e49"></a>ALT_I2C_TX_ABORT_CAUSE_ARB_LOST</em>&nbsp;</td><td>
<p>Master Abort Arbitration Lost - If set (1), master has lost arbitration, or if IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost arbitration. Note: I2C can be both master and slave at the same time.</p>
<p>Role of I2C: Master or Slave-Transmitter. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfac0c26aa1362ddfc9cc0bac1c67cca2fe"></a>ALT_I2C_TX_ABORT_CAUSE_SLVFLUSH_TXFIFO</em>&nbsp;</td><td>
<p>Slave Abort Flush TXFIFO - If set (1), Slave has received a read command and some data exists in the TX FIFO so the slave issues a TX_ABRT interrupt to flush old data in TX FIFO.</p>
<p>Role of I2C: Slave-Transmitter. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa598fa279cf304f1ab3792ef9a17b4e01"></a>ALT_I2C_TX_ABORT_CAUSE_SLV_ARBLOST</em>&nbsp;</td><td>
<p>Slave Abort Arbitration Lost - If set (1), Slave lost the bus while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time.</p>
<p>Note: Even though the slave never owns the bus, something could go wrong on the bus. This is a fail safe check. For instance, during a data transmission at the low-to-high transition of SCL, if what is on the data bus is not what is supposed to be transmitted, then DW_apb_i2c no longer own the bus.</p>
<p>Role of I2C: Slave-Transmitter. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga321dbe61df714c442640f1c4a908aabfa2614ceb1001e929a135764323c823992"></a>ALT_I2C_TX_ABORT_CAUSE_SLVRD_INTX</em>&nbsp;</td><td>
<p>Slave Abort Read TX - If set (1), when the processor side responds to a slave mode request for data to be transmitted to a remote master and user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.</p>
<p>Role of I2C: Slave-Transmitter. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga6c4e543ed4ae5b99e8e2ff02eae463cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___a_l_t___i2_c.html#ga1db51a8ca7c78d287a620a1f894ba1c5">ALT_I2C_CTLR_t</a>&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the specified I2C controller instance for use and return a device handle referencing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c</td><td>The HPS I2C controller instance to initialize.</td></tr>
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeabf95833cc757c3ff6315c13194777d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_reset </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset the specified I2C controller instance for use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae7cc51922c0e90eb3695c4757fb7eba3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_uninit </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uninitialize the I2C controller referenced by the <em>i2c_dev</em> handle.</p>
<p>This function attempts to gracefully shutdown the I2C controller by waiting for any inpcomplete transactions to finish and then putting the I2C controller into reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad16c19c9abacbfbe6f4501b0db490322"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_disable </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the I2C controller.</p>
<p>When the I2C controller is disabled, the following occurs:</p>
<ul>
<li>The TX FIFO and RX FIFO get flushed.</li>
<li>The I2C interrupt status conditions remain active until the I2C controller goes into IDLE state.</li>
</ul>
<p>If the controller is transmitting, it stops as well as deletes the contents of the transmit buffer after the current transfer is complete. If the module is receiving, the controller stops the current transfer at the end of the current byte and does not acknowledge the transfer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga60c931e6e918b963313fc729c5418289"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_enable </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the I2C controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga766698352e55a0abdf158be06c7faed1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_is_enabled </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns ALT_E_TRUE if the I2C controller is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33fc9aa9f017d7ae7eb0779415e9d69f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_config_get </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current configuration of the I2C controller when operating in master mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">cfg</td><td>[out] Pointer to a ALT_I2C_MASTER_CONFIG_t structure for holding the returned I2C master mode configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1e81c86d394a6cc962598e3e32931d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_config_set </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the configuration of the I2C controller with operational parameters for operating in master mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">cfg</td><td>Pointer to a ALT_I2C_MASTER_CONFIG_t structure holding the desired I2C master mode operational parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga90d8a89d7b447bede11a9c1c79ea3b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_config_speed_get </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>speed_in_hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a utility function that returns the speed based on parameters of the I2C master configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">cfg</td><td>A pointer to the master confugurations.</td></tr>
    <tr><td class="paramname">speed_in_hz</td><td>[out] Speed (Hz) of the I2C bus currently configured at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab7a9d3d9d126cce421b7a9e0254b2a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_config_speed_set </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>speed_in_hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a utility function that computes parameters for the I2C master configuration that best matches the speed requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">cfg</td><td>A pointer to the master confugurations.</td></tr>
    <tr><td class="paramname">speed_in_hz</td><td>Speed (Hz) of the I2C bus to configure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2db2575ff493909f71d05f9aa37848b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_slave_config_get </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___i2_c.html#ga9c0d22378cb1d6eb0194ca424026081d">ALT_I2C_SLAVE_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current configuration of the I2C controller when operating in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">cfg</td><td>[out] Pointer to a ALT_I2C_SLAVE_CONFIG_t structure for holding the returned I2C slave mode configuration parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf11d526a49799f04d8f5336bce0dde18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_slave_config_set </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_l_t___i2_c.html#ga9c0d22378cb1d6eb0194ca424026081d">ALT_I2C_SLAVE_CONFIG_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the configuration of the I2C controller with operational parameters for operating in slave mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">cfg</td><td>Pointer to a ALT_I2C_SLAVE_CONFIG_t structure holding the desired I2C slave mode operational parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga422d03c04681a4c27b1894ffe133213c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_op_mode_get </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_l_t___i2_c.html#ga15e9cb79693e43e74075112b2aebe1e2">ALT_I2C_MODE_t</a> *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current operational mode of the I2C controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">mode</td><td>[out] The current operational mode enabled for the I2C controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc79f16589bc6e18cfa6841d316c8109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_op_mode_set </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_l_t___i2_c.html#ga15e9cb79693e43e74075112b2aebe1e2">ALT_I2C_MODE_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the operational mode of the I2C controller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">mode</td><td>The operational mode to enable for the I2C controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga511834bf99afd6c808d4fdc593a40bde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_is_busy </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns ALT_E_TRUE if the I2C controller is busy. The I2C controller is busy if either the Slave Finite State Machine (FSM) is not in the IDLE state or the Master Finite State Machine (FSM) is not in the IDLE state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4fef6676a5473f870bf441d29932239b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_read </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function reads a single data byte from the receive FIFO.</p>
<p>This function is used to perform low level access to the data bytes received by the I2C controller and buffered in the receive FIFO. It may be used by master-receivers or slave receivers.</p>
<p>This function does not check for valid data in the receive FIFO beforehand and may cause an underflow if improperly used. It is meant to be called from a context where preconditions have been previously asserted such as in the implementation of the <a class="el" href="group___a_l_t___i2_c.html#gaadba976480855d6b962cd0abbdb01c42">alt_i2c_slave_receive()</a> or <a class="el" href="group___a_l_t___i2_c.html#gab88766a82c41e49ba2802ac482aa7e44">alt_i2c_master_receive()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">val</td><td>[out] The single data byte read from the receive FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22c701c3cecc56086156a0cde75277ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_write </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes a single data byte to the transmit FIFO.</p>
<p>This function is used to perform low level writes of data to the transmit FIFO for transmission by the I2C controller. It may be used by slave receivers.</p>
<p>This function does not check whether the transmit FIFO is full or not beforehand and may cause an overflow if improperly used. It is meant to be called from a context where preconditions have been previously asserted such as in the implementation of the <a class="el" href="group___a_l_t___i2_c.html#ga3137e57044cb1f6d1b8ce9b09baf61e3">alt_i2c_slave_transmit()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">val</td><td>The data byte to write to the transmission FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaadba976480855d6b962cd0abbdb01c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_slave_receive </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function acts in the role of a slave-receiver by receiving a single data byte from the I2C bus in response to a write command from the master.</p>
<p>This API is suitable for being called during an interrupt context. It is the programmer's responsibility to ensure that there is data in the RX FIFO to accomodate the request made.</p>
<p>The I2C controller must be in slave mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">data</td><td>[out] A pointer to a buffer to contain the received data byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3137e57044cb1f6d1b8ce9b09baf61e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_slave_transmit </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function acts in the role of a slave-transmitter by transmitting a single data byte to the I2C bus in response to a read request from the master.</p>
<p>This API is suitable for being called during an interrupt context. It is the programmer's responsibility to ensure that there is enough space in the TX FIFO to accomodate the request made.</p>
<p>The I2C controller must be in slave mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">data</td><td>The data byte to transmit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0328c19c0b8da8349533947b15ae291d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_slave_bulk_transmit </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function acts in the role of a slave-transmitter by transmitting data in bulk to the I2C bus in response to a series of read requests from a master.</p>
<p>In the standard I2C protocol, all transactions are single byte transactions and the slave responds to a remote master read request by writing one byte into the slave's TX FIFO. When a slave (slave-transmitter) is issued with a read request from the remote master (master-receiver), at a minimum there should be at least one entry placed into the slave-transmitter's TX FIFO. The I2C controller is capable of handling more data in the TX FIFO so that subsequent read requests can receive that data without raising an interrupt or software having to poll to request more data. This eliminates overhead latencies from being incurred by servicing the interrupt or polling for data requests each time had there been a restriction of having only one entry placed in the TX FIFO.</p>
<p>If the remote master acknowledges the data sent by the slave-transmitter and there is no data in the slave's TX FIFO, the I2C controller raises the read request interrupt and waits for data to be written into the TX FIFO before it can be sent to the remote master.</p>
<p>If the programmer knows in advance that the master is requesting a packet of <em>n</em> bytes, then when another master request for data is received, the TX FIFO could be written with <em>n</em> number bytes and the master receives it as a continuous stream of data. For example, the slave continues to send data to the master as long as the master is acknowledging the data sent and there is data available in the TX FIFO. There is no need to hold the SCL line low or to issue READ request again.</p>
<p>If the remote master is to receive <em>n</em> bytes from the slave but the programmer wrote a number of bytes larger than <em>n</em> to the TX FIFO, then when the slave finishes sending the requested <em>n</em> bytes, it clears the TX FIFO and ignores any excess bytes.</p>
<p>This API is suitable for being called during an interrupt context. It is the programmer's responsibility to ensure that there is enough space in the TX FIFO to accomodate the request made.</p>
<p>The I2C controller must be in slave mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the data buffer to transmit.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data buffer in bytes to place in the TX FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa24c8832ba8eb5643a4455adfaf48b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_target_get </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>target_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the current target address.</p>
<p>The I2C controller must be in master mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">target_addr</td><td>[out] The 7 or 10 bit slave target address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9069f423699fb1a1a7ba60ce524a8320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_target_set </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>target_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function updates the target slave address for any upcoming I2C bus IO.</p>
<p>This API is not suitlabe for being called in an interrupt context as it will wait for the TX FIFO to flush before applying the changes. If the TX FIFO is known to be empty and the controller idle, then it can be safely called.</p>
<p>The I2C controller must be in master mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">target_addr</td><td>The 7 or 10 bit slave target address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaed6d67ba8f5200395f72d89bae1bb0c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_transmit </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_restart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function acts in the role of a master-transmitter by issuing a write command and transmitting data to the I2C bus.</p>
<p>This API is not suitable for being called in an interrupt context as it may wait for certain controller states before completing.</p>
<p>The I2C controller must be in master mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to a data buffer to transmit</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data buffer in bytes to place in the TX FIFO.</td></tr>
    <tr><td class="paramname">issue_restart</td><td>This parameter controls whether a RESTART is issued before the byte is sent or received. If:<ul>
<li><b>true</b> - if <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
<li><b>false</b> - If <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued only if the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
</ul>
</td></tr>
    <tr><td class="paramname">issue_stop</td><td>This parameter controls whether a STOP is issued after the byte is sent or received. If:<ul>
<li><b>true</b> - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.</li>
<li><b>false</b> - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab88766a82c41e49ba2802ac482aa7e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_master_receive </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_restart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function acts in the role of a master-receiver by receiving one or more data bytes transmitted from a slave in response to read requests issued from this master.</p>
<p>This function causes the master to issue the required number of read requests to the slave and read the received data bytes from the Rx FIFO.</p>
<p>The <em>issue_restart</em> and <em>issue_stop</em> parameters apply to the final read request transaction in the <em>num_data_entries</em> sequence required to fulfill the aggregate receive request.</p>
<p>This API is not suitable for being called in an interrupt context as it may wait for certain controller states before completing.</p>
<p>The I2C controller must be in master mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">data</td><td>[out] The data buffer to receive the requested <em>size</em> bytes.</td></tr>
    <tr><td class="paramname">size</td><td>The size of the data buffer to read from the RX FIFO.</td></tr>
    <tr><td class="paramname">issue_restart</td><td>This parameter controls whether a RESTART is issued before the byte is sent or received. If:<ul>
<li><b>true</b> - if <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
<li><b>false</b> - If <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued only if the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
</ul>
</td></tr>
    <tr><td class="paramname">issue_stop</td><td>This parameter controls whether a STOP is issued after the byte is sent or received. If:<ul>
<li><b>true</b> - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.</li>
<li><b>false</b> - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga26da61779581c9bb4b6f64c59c355e13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_issue_read </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_restart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function causes the I2C controller master to issue a READ request on the bus. This function is typically used during master-receiver transfers.</p>
<p>The I2C controller must be in master mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">issue_restart</td><td>This parameter controls whether a RESTART is issued before the byte is sent or received. If:<ul>
<li><b>true</b> - if <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
<li><b>false</b> - If <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued only if the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
</ul>
</td></tr>
    <tr><td class="paramname">issue_stop</td><td>This parameter controls whether a STOP is issued after the byte is sent or received. If:<ul>
<li><b>true</b> - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.</li>
<li><b>false</b> - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04427056d32e48df6a386a645bc5df91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ALT_STATUS_CODE alt_i2c_issue_write </td>
          <td>(</td>
          <td class="paramtype">ALT_I2C_DEV_t *&#160;</td>
          <td class="paramname"><em>i2c_dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_restart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>issue_stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function causes the I2C controller master to issue a send byte on the bus. This function is typically used during master-transmitter/slave-transmitter transfers.</p>
<p>The I2C controller must be in master mode before calling this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i2c_dev</td><td>A pointer to the I2C controller device block instance.</td></tr>
    <tr><td class="paramname">value</td><td>The data item to be transmitted.</td></tr>
    <tr><td class="paramname">issue_restart</td><td>This parameter controls whether a RESTART is issued before the byte is sent or received. If:<ul>
<li><b>true</b> - if <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued before the data is sent/received (according to the value of CMD), regardless of whether or not the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
<li><b>false</b> - If <em>restart_enabled</em> in <a class="el" href="group___a_l_t___i2_c.html#ga4f317dbba3080bb537f6c145ca30d503">ALT_I2C_MASTER_CONFIG_t</a> is <b>true</b>, a RESTART is issued only if the transfer direction is changing from the previous command; if <em>restart_enabled</em> is <b>false</b>, a STOP followed by a START is issued instead.</li>
</ul>
</td></tr>
    <tr><td class="paramname">issue_stop</td><td>This parameter controls whether a STOP is issued after the byte is sent or received. If:<ul>
<li><b>true</b> - STOP is issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master immediately tries to start a new transfer by issuing a START and arbitrating for the bus.</li>
<li><b>false</b> - STOP is not issued after this byte, regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the master continues the current transfer by sending/receiving data bytes according to the value of the CMD bit. If the Tx FIFO is empty, the master holds the SCL line low and stalls the bus until a new command is available in the Tx FIFO.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ALT_E_SUCCESS</td><td>Successful status. </td></tr>
    <tr><td class="paramname">ALT_E_ERROR</td><td>Details about error status code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 13 2018 01:57:45 for Altera HWLIB by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
